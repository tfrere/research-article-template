<div class="d3-trackio-oblivion">
  <div class="d3-trackio-oblivion__grid">
    <div class="cell" data-metric="epoch" data-title="epoch"></div>
    <div class="cell" data-metric="train_accuracy" data-title="train_accuracy"></div>
    <div class="cell" data-metric="train_loss" data-title="train_loss"></div>
    <div class="cell" data-metric="val_accuracy" data-title="val_accuracy"></div>
    <div class="cell cell--wide" data-metric="val_loss" data-title="val_loss"></div>
  </div>
  <noscript>JavaScript is required to render this chart.</noscript>
</div>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;600;700&display=swap');
  /* Futuristic "Oblivion"-inspired styling */
  .d3-trackio-oblivion { position: relative;
    --cell-gap: 0px;
    /* Default: light/neutral theme */
    --obl-base: #323232; /* base hue for the UI (light theme) */
    --obl-cyan: var(--obl-base);
    --obl-cyan-dim: color-mix(in srgb, var(--obl-base) 28%, transparent);
    --obl-bg: color-mix(in srgb, var(--obl-base) 4%, transparent);
    --obl-border: color-mix(in srgb, var(--obl-base) 22%, transparent);
    --ghost-obl-border: color-mix(in srgb, var(--obl-base) 6%, transparent);
    --obl-glow: 0 0 0 1px color-mix(in srgb, var(--obl-base) 5%, transparent), 0 8px 40px color-mix(in srgb, var(--obl-base) 6%, transparent);
    /* Engraved separator colors (light theme) */
    --engrave-light: color-mix(in srgb, white 15%, transparent);
    --engrave-dark: color-mix(in srgb, var(--obl-base) 10%, transparent);
    background: transparent;
    --corner-inset: 6px;
    --hud-gap: 10px;
    --hud-corner-size: 8px;
    /* Chart background gradient as a variable for easy theming */
    --hud-bg-gradient: radial-gradient(1200px 200px at 20% -10%, rgba(0,0,0,.05), transparent 80%), radial-gradient(900px 200px at 80% 110%, rgba(0,0,0,.05), transparent 80%);
    /* Tooltip offset (bottom-right of cursor) */
    --tip-offset-x: 10px;
    --tip-offset-y: 10px;
    padding: var(--hud-gap);
    --z-tooltip: 50;
    --z-overlay: 99999999;
    z-index: var(--z-tooltip);
    font-family: 'Roboto Mono', ui-monospace, SFMono-Regular, Menlo, monospace;
 }
  .d3-trackio-oblivion * { font-family: inherit;
   }
  /* Dark mode: cyan/Oblivion theme */
  [data-theme="dark"] .d3-trackio-oblivion {
    --obl-base: #ffffff; /* base hue for the UI (dark theme) */
    --obl-cyan: var(--obl-base);
    --obl-cyan-dim: color-mix(in srgb, var(--obl-base) 25%, transparent);
    --obl-bg: color-mix(in srgb, var(--obl-base) 6%, transparent);
    --obl-border: color-mix(in srgb, var(--obl-base) 25%, transparent);
    --ghost-obl-border: color-mix(in srgb, var(--obl-base) 2%, transparent);
    --obl-glow: 0 0 0 1px color-mix(in srgb, var(--obl-base) 35%, transparent), 0 8px 40px color-mix(in srgb, var(--obl-base) 12%, transparent);
    /* Richer cyan gradients for the classic Oblivion blue feel */
    --hud-bg-gradient:
      radial-gradient(1400px 260px at 20% -10%, color-mix(in srgb, var(--obl-base) 6.5%, transparent), transparent 80%),
      radial-gradient(1100px 240px at 80% 110%, color-mix(in srgb, var(--obl-base) 6%, transparent), transparent 80%),
      linear-gradient(180deg, color-mix(in srgb, var(--obl-base) 3.5%, transparent), transparent 45%);
    /* Engraved separator colors (dark theme) */
    --engrave-light: color-mix(in srgb, var(--obl-base) 5%, transparent);
    --engrave-dark: color-mix(in srgb, black 15%, transparent);
    background: #0f1115;
  }
  /* Tooltip shadows: neutral by default, bluish tint in dark */
  .d3-trackio-oblivion .d3-tooltip { box-shadow: 0 8px 32px color-mix(in srgb, var(--obl-base) 8%, transparent), 0 2px 8px color-mix(in srgb, var(--obl-base) 6%, transparent); }
  [data-theme="dark"] .d3-trackio-oblivion .d3-tooltip { box-shadow: 0 8px 32px color-mix(in srgb, var(--obl-base) 5%, transparent), 0 2px 8px color-mix(in srgb, black 10%, transparent); }

  .d3-trackio-oblivion__grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: --cell-gap; }
  @media (max-width: 980px) { .d3-trackio-oblivion__grid { grid-template-columns: 1fr; } }
  .d3-trackio-oblivion__grid .cell--wide { grid-column: 1 / -1; }

  .d3-trackio-oblivion .cell {
    /* border: 1px solid var(--obl-border);
    border-radius: 4px;
    background: var(--obl-bg);
    backdrop-filter: saturate(1.1) blur(10px);
    box-shadow: var(--obl-glow); */
    display: flex;
    flex-direction: column;
    position: relative;
    /* Important: allow tooltip to overflow outside cell bounds */
    overflow: visible;
    z-index: 0;
  }
  .d3-trackio-oblivion .cell:hover { z-index: 50; }
  /* Background and corners are explicit elements for maintainability */
  .d3-trackio-oblivion .cell-bg { position: absolute; inset: var(--hud-gap); pointer-events: none; z-index: 1; background: var(--hud-bg-gradient); }
  .d3-trackio-oblivion .cell-corners { position: absolute; inset: var(--corner-inset); pointer-events: none; z-index: 3; background:
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) top left / var(--hud-corner-size) 1px no-repeat,
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) top left / 1px var(--hud-corner-size) no-repeat,
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) top right / var(--hud-corner-size) 1px no-repeat,
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) top right / 1px var(--hud-corner-size) no-repeat,
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) bottom left / var(--hud-corner-size) 1px no-repeat,
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) bottom left / 1px var(--hud-corner-size) no-repeat,
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) bottom right / var(--hud-corner-size) 1px no-repeat,
      linear-gradient(var(--obl-cyan), var(--obl-cyan)) bottom right / 1px var(--hud-corner-size) no-repeat; opacity:.85; }
  .d3-trackio-oblivion .cell-inner { position: relative; z-index: 2; padding: var(--hud-corner-size) 12px 10px var(--hud-gap); display:flex; flex-direction:column; }
  .d3-trackio-oblivion .cell-header { padding: 10px 6px 10px 12px; display: flex; align-items: center; justify-content: space-between; gap: 8px; }
  .d3-trackio-oblivion .cell-title { position: relative; font-size: 12px; font-weight: 800; letter-spacing: 0.12em; text-transform: uppercase; color: var(--obl-cyan); padding-left: 14px; }
  .d3-trackio-oblivion .cell-title:before { content:""; position:absolute; left:0; top:50%; transform:translateY(-50%); width: 6px; height: 6px; background: var(--obl-cyan); border: 1px solid var(--obl-border); box-shadow: 0 0 10px color-mix(in srgb, var(--obl-base) 25%, transparent) inset; opacity: .5; }
  /* Fullscreen button (icon only, no behavior here) */
  .d3-trackio-oblivion .cell-action { padding: 0 !important; margin-left: auto; display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; border: 0; background: transparent; color: var(--obl-cyan); opacity: .5; cursor: pointer; z-index: 4; }
  .d3-trackio-oblivion .cell-action:hover { opacity: .7; }
  .d3-trackio-oblivion .cell-action svg { width: 22px; height: 22px; opacity: .6; margin-left: 5px; }
  .d3-trackio-oblivion .cell-action svg, .d3-trackio-oblivion .cell-action svg path { fill: currentColor; stroke: none; }
  [data-theme="dark"] .d3-trackio-oblivion .cell-action svg { opacity: .85; }
  .d3-trackio-oblivion .cell-body { position: relative; width: 100%; overflow: hidden; }
  .d3-trackio-oblivion .cell-body svg { max-width: 100%; height: auto; display: block; }

  /* Axes & grid use cyan tint */
  .d3-trackio-oblivion .axes path, .d3-trackio-oblivion .axes line { stroke: var(--obl-cyan-dim); stroke-opacity: 1; }
  .d3-trackio-oblivion .axes text { fill: var(--obl-cyan); opacity: .6; font-weight: 400; letter-spacing: 0.02em; }
  .d3-trackio-oblivion .grid line { stroke: var(--obl-cyan-dim); stroke-opacity: .5; }

  /* Legend header */
  .d3-trackio-oblivion__header { display: flex; align-items: flex-start; justify-content: center; gap: 14px; margin: 0 0 10px 0; flex-wrap: wrap; width: 100%; }
  .d3-trackio-oblivion__header .legend-bottom { display: flex; flex-direction: column; align-items: center; gap: 6px; font-size: 12px; color: var(--obl-cyan); text-align: center; }
  .d3-trackio-oblivion__header .legend-bottom .legend-title { font-size: 11px; font-weight: 900; letter-spacing: 0.18em; color: var(--obl-cyan); text-transform: uppercase; }
  .d3-trackio-oblivion__header .legend-bottom .items { display: flex; flex-wrap: wrap; gap: 8px 14px; }
  .d3-trackio-oblivion__header .legend-bottom .item { display: inline-flex; align-items: center; gap: 6px; white-space: nowrap; color: var(--obl-cyan); }
  .d3-trackio-oblivion__header .legend-bottom .swatch { width: 14px; height: 14px; border-radius: 2px; border: 1px solid var(--ghost-obl-border); display: inline-block; box-shadow: 0 0 12px color-mix(in srgb, var(--obl-base) 18%, transparent) inset; }

  /* Hover ghosting */
  .d3-trackio-oblivion.hovering .lines path.ghost { opacity: .22; }
  .d3-trackio-oblivion.hovering .points circle.ghost { opacity: .22; }
  .d3-trackio-oblivion.hovering .areas path.ghost { opacity: .06; }
  .d3-trackio-oblivion.hovering .legend-bottom .item.ghost { opacity: .35; }

  /* Tooltip */
  .d3-trackio-oblivion .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    background: var(--obl-bg);
    color: var(--obl-cyan);
    box-shadow: 0 8px 32px rgba(127,241,255,.05), 0 2px 8px rgba(0,0,0,.10);
    opacity: .5;
    transition: opacity .12s ease;
    z-index: 1000;
    backdrop-filter: saturate(1.1) blur(10px);
  }
  .d3-trackio-oblivion .d3-tooltip.is-visible { opacity: 1; }
  .d3-trackio-oblivion .d3-tooltip__inner { display: flex; flex-direction: column; gap: 6px; min-width: 220px; text-align: left; }
  .d3-trackio-oblivion .d3-tooltip__inner > div:first-child { font-weight: 900; letter-spacing: .18em; text-transform: uppercase; color: var(--obl-cyan); }
  .d3-trackio-oblivion .d3-tooltip__inner > div:nth-child(2) { font-size: 11px; color: var(--obl-cyan); opacity: .4; display: block; margin-top: -4px; margin-bottom: 2px; letter-spacing: 0.06em; }
  .d3-trackio-oblivion .d3-tooltip__inner > div:nth-child(n+3) { position: relative; padding-top: 10px; margin-top: 6px; }
  .d3-trackio-oblivion .d3-tooltip__inner > div:nth-child(n+3)::before { content:""; position:absolute; left:0; right:0; top:0; height:1px; background: var(--engrave-dark); }
  .d3-trackio-oblivion .d3-tooltip__inner > div:nth-child(n+3)::after { content:""; position:absolute; left:0; right:0; top:1px; height:1px; background: var(--engrave-light); }
  .d3-trackio-oblivion .d3-tooltip__color-dot { display: inline-block; width: 12px; height: 12px; border-radius: 2px; border: 1px solid var(--obl-border); box-shadow: 0 0 10px color-mix(in srgb, var(--obl-base) 20%, transparent) inset; }
</style>
<script>
  (() => {
    const THIS_SCRIPT = document.currentScript;
    const TARGET_METRICS = ['epoch','train_accuracy','train_loss','val_accuracy','val_loss'];

    const prettyMetricLabel = (key) => {
      if (!key) return '';
      const table = { 'train_accuracy':'Train Accuracy', 'val_accuracy':'Val Accuracy', 'train_loss':'Train Loss', 'val_loss':'Val Loss', 'epoch':'Epoch' };
      if (table[key]) return table[key];
      const cleaned = String(key).replace(/[_-]+/g, ' ').trim();
      return cleaned.split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    };

    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    function initCell(cell){
      const d3 = window.d3;
      const metricKey = cell.getAttribute('data-metric');
      const titleText = cell.getAttribute('data-title') || metricKey;
      // Structured layers: bg + corners + inner (header + svg)
      const bg = document.createElement('div'); bg.className = 'cell-bg'; cell.appendChild(bg);
      const corners = document.createElement('div'); corners.className = 'cell-corners'; cell.appendChild(corners);
      const inner = document.createElement('div'); inner.className = 'cell-inner'; cell.appendChild(inner);
      const header = document.createElement('div'); header.className = 'cell-header';
      const title = document.createElement('div'); title.className = 'cell-title'; title.textContent = prettyMetricLabel(titleText); header.appendChild(title);
      // Fullscreen icon button (no click handler here)
      const fsBtn = document.createElement('button'); fsBtn.className = 'cell-action cell-action--fullscreen'; fsBtn.type = 'button'; fsBtn.title = 'Fullscreen'; fsBtn.setAttribute('aria-label', 'Open fullscreen');
      fsBtn.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 9V4h5v2H6v3H4zm10-5h5v5h-2V6h-3V4zM6 18h3v2H4v-5h2v3zm12-3h2v5h-5v-2h3v-3z"/></svg>';
      header.appendChild(fsBtn);
      inner.appendChild(header);

      const body = document.createElement('div'); body.className = 'cell-body'; inner.appendChild(body);
      const svg = d3.select(body).append('svg').attr('width','100%').style('display','block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class','grid');
      const gAxes = gRoot.append('g').attr('class','axes');
      const gAreas = gRoot.append('g').attr('class','areas');
      const gLines = gRoot.append('g').attr('class','lines');
      const gPoints = gRoot.append('g').attr('class','points');
      const gHover = gRoot.append('g').attr('class','hover');
      const host = cell.closest('.d3-trackio-oblivion');

      // Tooltip
      cell.style.position = cell.style.position || 'relative';
      let tip = cell.querySelector('.d3-tooltip'); let tipInner; let hideTipTimer = null;
      if (!tip) { tip = document.createElement('div'); tip.className = 'd3-tooltip'; tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tip.appendChild(tipInner); cell.appendChild(tip); } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Layout & scales
      let width = 800, height = 180; const margin = { top: 12, right: 20, bottom: 36, left: 44 };
      let xScale = d3.scaleLinear(); const yScale = d3.scaleLinear();
      const lineGen = d3.line().x(d => xScale(0)).y(d => yScale(d.value));

      // Generic number abbreviation for axis ticks (K/M/B) with up to 2 decimals
      const formatAbbrev = (value) => {
        const num = Number(value);
        if (!Number.isFinite(num)) return String(value);
        const abs = Math.abs(num);
        const trim2 = (n) => Number(n).toFixed(2).replace(/\.?0+$/, '');
        if (abs >= 1e9) return `${trim2(num / 1e9)}B`;
        if (abs >= 1e6) return `${trim2(num / 1e6)}M`;
        if (abs >= 1e3) return `${trim2(num / 1e3)}K`;
        return trim2(num);
      };

      function updateLayout(axisLabelY, xTicksArg){
        const rect = cell.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (cell.clientWidth || 800)));
        height = 180;
        svg.attr('width', width).attr('height', height).attr('viewBox', `0 0 ${width} ${height}`).attr('preserveAspectRatio','xMidYMid meet');
        // Respect HUD gap: keep content inside gradient inset
        const css = getComputedStyle(cell);
        const hudGap = Math.max(0, parseFloat(css.getPropertyValue('--hud-gap')) || 0);
        const innerWidth = Math.max(0, width - margin.left - margin.right - hudGap * 2);
        const innerHeight = Math.max(0, height - margin.top - margin.bottom - hudGap * 2);
        gRoot.attr('transform', `translate(${margin.left + hudGap},${margin.top + hudGap})`);
        xScale.range([0, innerWidth]); yScale.range([innerHeight, 0]);
        // grid cleared; drawn as dot intersections in render()
        gGrid.selectAll('*').remove();
        gAxes.selectAll('*').remove();
        // Build ticks that always include domain edges
        const makeTicks = (scale, approx) => {
          const arr = scale.ticks(approx);
          const dom = scale.domain();
          if (arr.length === 0 || arr[0] !== dom[0]) arr.unshift(dom[0]);
          if (arr[arr.length - 1] !== dom[dom.length - 1]) arr.push(dom[dom.length - 1]);
          // dedupe
          return Array.from(new Set(arr));
        };
        const xTicksForced = (Array.isArray(xTicksArg) && xTicksArg.length)
          ? Array.from({ length: xTicksArg.length }, (_, i) => i)
          : makeTicks(xScale, 8);
        const yCount = Math.max(2, Math.min(6, xTicksForced.length));
        const yDom = yScale.domain();
        const yTicksForced = (yCount <= 2)
          ? [yDom[0], yDom[1]]
          : Array.from({ length: yCount }, (_, i) => yDom[0] + ((yDom[1] - yDom[0]) * (i / (yCount - 1))));
        gAxes
          .append('g')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(
            d3.axisBottom(xScale)
              .tickValues(xTicksForced)
              .tickFormat((i) => {
                const val = (Array.isArray(xTicksArg) && xTicksArg[i] != null ? xTicksArg[i] : i);
                return formatAbbrev(val);
              })
          )
          .call((g) => {
            g.selectAll('path.domain').attr('stroke', 'var(--obl-cyan-dim)');
            g.selectAll('.tick line')
              .attr('stroke', 'var(--obl-cyan-dim)')
              .attr('y1', 4)
              .attr('y2', 6);
            g.selectAll('text')
              .attr('fill', 'var(--obl-cyan)')
              .style('font-size', '11px');
          });

        gAxes
          .append('g')
          .call(d3.axisLeft(yScale).tickValues(yTicksForced).tickFormat((v) => formatAbbrev(v)))
          .call((g) => {
            g.selectAll('path.domain').attr('stroke', 'var(--obl-cyan-dim)');
            g.selectAll('.tick line')
              .attr('stroke', 'var(--obl-cyan-dim)')
              .attr('x1', -4)
              .attr('x2', -6);
            g.selectAll('text')
              .attr('fill', 'var(--obl-cyan)')
              .style('font-size', '11px');
          });
        gAxes
          .append('text')
          .attr('class','x-axis-label')
          .attr('x', innerWidth/2)
          .attr('y', innerHeight + Math.max(22, Math.min(36, margin.bottom - 2)))
          .attr('fill', 'var(--obl-cyan)')
          .attr('text-anchor', 'middle')
          .style('font-size','9px')
          .style('opacity', '0.3')
          .style('font-weight','500')
          .style('letter-spacing','.12em')
          .style('text-transform','uppercase')
          .text('Steps');
        // Y-axis label removed to gain horizontal space
        return { innerWidth, innerHeight, xTicksForced, yTicksForced };
      }

      function render(metricData, colorForRun){
        const runs = Object.keys(metricData || {});
        const hasAny = runs.some(r => (metricData[r]||[]).length > 0);
        if (!hasAny) { gRoot.style('display','none'); let msg = body.querySelector('.empty-msg'); if (!msg) { msg = document.createElement('div'); msg.className='empty-msg'; msg.textContent='Metric not found in data.'; Object.assign(msg.style,{ padding:'10px', fontSize:'12px', color:'var(--obl-cyan)', opacity:.6 }); body.appendChild(msg); } return; }
        const msg = body.querySelector('.empty-msg'); if (msg) msg.remove(); gRoot.style('display', null);

        let minStep = Infinity, maxStep = -Infinity, minVal = Infinity, maxVal = -Infinity;
        runs.forEach(r => { (metricData[r]||[]).forEach(pt => { minStep = Math.min(minStep, pt.step); maxStep = Math.max(maxStep, pt.step); minVal = Math.min(minVal, pt.value); maxVal = Math.max(maxVal, pt.value); }); });
        if (!isFinite(minStep) || !isFinite(maxStep)) return;
        const isAccuracy = /accuracy/i.test(metricKey);
        const axisLabelY = prettyMetricLabel(metricKey);
        if (isAccuracy) yScale.domain([0,1]).nice(); else yScale.domain([minVal, maxVal]).nice();
        // Compute unique x steps and build index mapping
        const rawSteps = [];
        runs.forEach(r => (metricData[r]||[]).forEach(pt => rawSteps.push(pt.step)));
        const hoverSteps = Array.from(new Set(rawSteps)).sort((a,b)=>a-b);
        const stepIndex = new Map(hoverSteps.map((s,i)=>[s,i]));
        const indices = hoverSteps.map((_, i) => i);
        // Linear index scale → ticks at edges, equal spacing
        xScale = d3.scaleLinear().domain([0, Math.max(0, indices.length - 1)]);
        // Update line generator X accessor to use index directly
        lineGen.x(d => xScale(stepIndex.get(d.step)));
        const { innerWidth, innerHeight, xTicksForced, yTicksForced } = updateLayout(axisLabelY, hoverSteps);

        // Grid as small dots at intersections of y ticks × step positions
        // Exclude dots that fall on the origin axes lines (left Y-axis and bottom X-axis)
        const gridPoints = [];
        const yDomAll = yScale.domain();
        const yMin = Array.isArray(yDomAll) ? yDomAll[0] : null;
        xTicksForced.forEach(i => {
          yTicksForced.forEach(t => {
            if (i !== 0 && (yMin == null || t !== yMin)) {
              gridPoints.push({ sx: i, ty: t });
            }
          });
        });
        gGrid.selectAll('circle.grid-dot')
          .data(gridPoints)
          .join('circle')
          .attr('class', 'grid-dot')
          .attr('cx', d => xScale(d.sx))
          .attr('cy', d => yScale(d.ty))
          .attr('r', 1.25)
          .attr('fill', 'var(--obl-cyan-dim)')
          .attr('fill-opacity', 0.5);

        // No stderr correction shapes for now (kept intentionally minimal)
        gAreas.selectAll('*').remove();

        // Lines
        const series = runs.map(r => ({ run:r, color: colorForRun(r), values:(metricData[r]||[]).slice().sort((a,b)=>a.step-b.step) }));
        const paths = gLines.selectAll('path.run').data(series, d=>d.run);
        paths.enter().append('path').attr('class','run').attr('fill','none').attr('stroke-width',1.8).attr('opacity',0.95).attr('stroke', d=>d.color).attr('d', d=>lineGen(d.values));
        paths.transition().duration(260).attr('stroke', d=>d.color).attr('opacity',0.95).attr('d', d=>lineGen(d.values));
        paths.exit().remove();

        // Points
        const allPts = series.flatMap(s => s.values.map(v => ({ run:s.run, color:s.color, step:v.step, value:v.value })));
        const ptsSel = gPoints.selectAll('circle.pt').data(allPts, d=>`${d.run}-${d.step}`);
        ptsSel.enter().append('circle')
          .attr('class','pt')
          .attr('r', 2)
          .attr('fill', d=>d.color)
          .attr('stroke','none')
          .attr('cx', d=> xScale(stepIndex.get(d.step)))
          .attr('cy', d=>yScale(d.value))
          .merge(ptsSel)
          .transition().duration(150)
          .attr('cx', d=> xScale(stepIndex.get(d.step)))
          .attr('cy', d=>yScale(d.value));
        ptsSel.exit().remove();
        // Steps used for hover snapping (unique data steps)
        // already computed above as hoverSteps

        // Hover
        gHover.selectAll('*').remove();
        const overlay = gHover.append('rect').attr('fill','transparent').style('cursor','crosshair').attr('x',0).attr('y',0).attr('width', innerWidth).attr('height', innerHeight);
        const hoverLine = gHover.append('line').style('stroke','var(--obl-cyan)').attr('stroke-opacity', 0.35).attr('stroke-width',1).attr('y1',0).attr('y2',innerHeight).style('display','none');
        // External hover handlers
        cell.__showExternalStep = (stepVal) => {
          if (stepVal == null) { hoverLine.style('display','none'); return; }
          const idx = stepIndex.get(stepVal);
          if (idx == null) { hoverLine.style('display','none'); return; }
          const xpx = xScale(idx);
          hoverLine.attr('x1',xpx).attr('x2',xpx).style('display',null);
        };
        cell.__clearExternalStep = () => { hoverLine.style('display','none'); };
        if (!cell.__syncAttached && host) {
          host.addEventListener('trackio-hover-step', (ev) => { const d = ev && ev.detail; if (!d) return; if (cell.__showExternalStep) cell.__showExternalStep(d.step); });
          host.addEventListener('trackio-hover-clear', () => { if (cell.__clearExternalStep) cell.__clearExternalStep(); });
          cell.__syncAttached = true;
        }
        function onMove(ev){ if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; } const [mx,my]=d3.pointer(ev, overlay.node()); const idx = Math.round(Math.max(0, Math.min(hoverSteps.length-1, xScale.invert(mx)))); const nearest = hoverSteps[idx]; const xpx = xScale(idx); hoverLine.attr('x1',xpx).attr('x2',xpx).style('display',null); if (host) { try { host.dispatchEvent(new CustomEvent('trackio-hover-step', { detail: { step: nearest } })); } catch(_){} } let html = `<div>Step ${formatAbbrev(nearest)}</div><div>${prettyMetricLabel(metricKey)}</div>`; const entries = series.map(s=>{ const m = new Map(s.values.map(v=>[v.step, v])); const pt = m.get(nearest); return { run:s.run, color:s.color, pt }; }).filter(e => e.pt && e.pt.value!=null); entries.sort((a,b)=> (a.pt.value - b.pt.value)); const fmt = (vv)=> (isAccuracy? (+vv).toFixed(4) : (+vv).toFixed(4)); entries.forEach(e => { html += `<div style=\"display:flex;align-items:center;gap:8px;white-space:nowrap;\"><span class=\"d3-tooltip__color-dot\" style=\"background:${e.color}\"></span><strong>${e.run}</strong><span style=\"margin-left:auto;text-align:right;\">${fmt(e.pt.value)}</span></div>`; }); tipInner.innerHTML = html; const cssVars = getComputedStyle(cell); const offx = Math.max(0, parseFloat(cssVars.getPropertyValue('--tip-offset-x')) || 0); const offy = Math.max(0, parseFloat(cssVars.getPropertyValue('--tip-offset-y')) || 0); const cellRect = cell.getBoundingClientRect(); const cx = (ev && ev.clientX != null) ? ev.clientX : (cellRect.left + mx); const cy = (ev && ev.clientY != null) ? ev.clientY : (cellRect.top + my); const x = cx - cellRect.left + offx; const y = cy - cellRect.top + offy; tip.classList.add('is-visible'); tip.style.transform=`translate(${x}px, ${y}px)`; 
          // Animate points at the hovered step to grow slightly
          try {
            gPoints.selectAll('circle.pt')
              .transition().duration(140).ease(d3.easeCubicOut)
              .attr('r', d => (d && d.step === nearest ? 4 : 2));
          } catch(_) {}
        }
        function onLeave(){ hideTipTimer = setTimeout(()=>{ tip.classList.remove('is-visible'); tip.style.transform='translate(-9999px, -9999px)'; hoverLine.style('display','none'); if (host) { try { host.dispatchEvent(new CustomEvent('trackio-hover-clear')); } catch(_){} } try { gPoints.selectAll('circle.pt').transition().duration(150).ease(d3.easeCubicOut).attr('r', 2); } catch(_) {} }, 100); }
        overlay.on('mousemove', onMove).on('mouseleave', onLeave);
      }

      return { metricKey, render };
    }

    const bootstrap = () => {
      const scriptEl = THIS_SCRIPT; let host = null; const header = document.createElement('div'); header.className = 'd3-trackio-oblivion__header'; const legend = document.createElement('div'); legend.className = 'legend-bottom'; legend.innerHTML = '<div class="legend-title">Runs</div><div class="items"></div>'; header.appendChild(legend);
      if (scriptEl && scriptEl.parentElement && scriptEl.parentElement.querySelector) host = scriptEl.parentElement.querySelector('.d3-trackio-oblivion'); if (!host) { let sib = scriptEl && scriptEl.previousElementSibling; while (sib && !(sib.classList && sib.classList.contains('d3-trackio-oblivion'))) { sib = sib.previousElementSibling; } host = sib || null; }
      if (!host) { host = document.querySelector('.d3-trackio-oblivion'); }
      if (!host) return; if (host.dataset && host.dataset.mounted==='true') return; if (host.dataset) host.dataset.mounted='true';

      // Insert legend header above the grid container
      const gridNode = host.querySelector('.d3-trackio-oblivion__grid');
      if (gridNode && gridNode.parentNode === host) { host.insertBefore(header, gridNode); } else { host.insertBefore(header, host.firstChild); }
      const cells = Array.from(host.querySelectorAll('.cell')); if (!cells.length) return;
      const instances = cells.map(cell => initCell(cell));

      // Read HtmlEmbed attributes
      let mountEl = host; while (mountEl && !mountEl.getAttribute?.('data-datafiles') && !mountEl.getAttribute?.('data-config')) { mountEl = mountEl.parentElement; }
      let providedData = null; let providedConfig = null;
      try { const attr = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-datafiles') : null; if (attr && attr.trim()) providedData = attr.trim().startsWith('[') ? JSON.parse(attr) : attr.trim(); } catch(_){ }
      try { const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null; if (cfg && cfg.trim()) providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg; } catch(_){ }

      const DEFAULT_CSV = '/data/trackio_wandb_demo.csv';
      const ensureDataPrefix = (p) => { if (typeof p !== 'string' || !p) return p; return p.includes('/') ? p : `/data/${p}`; };
      const normalizeInput = (inp) => Array.isArray(inp) ? inp.map(ensureDataPrefix) : (typeof inp === 'string' ? [ ensureDataPrefix(inp) ] : null);
      const CSV_PATHS = Array.isArray(providedData) ? normalizeInput(providedData) : (typeof providedData === 'string' ? normalizeInput(providedData) || [DEFAULT_CSV] : [ DEFAULT_CSV, './assets/data/trackio_wandb_demo.csv', '../assets/data/trackio_wandb_demo.csv', '../../assets/data/trackio_wandb_demo.csv' ]);

      const d3 = window.d3;
      (async () => {
        try {
          const texts = await Promise.all(CSV_PATHS.map(p => fetch(p, { cache:'no-cache' }).then(r => r.ok ? r.text() : '').catch(()=>'')));
          const textAll = texts.filter(Boolean).join('\n');
          const rows = d3.csvParse(textAll, d => ({ run:(d.run||'').trim(), step:+d.step, metric:(d.metric||'').trim(), value:+d.value, stderr: (d.stderr!=null && d.stderr!=='') ? +d.stderr : null }));
          // Filter out comments and invalid rows before building lists/maps
          const cleanRows = rows.filter(r => {
            const run = String(r.run||'').trim();
            const metric = String(r.metric||'').trim();
            return run && run.charAt(0) !== '#' && metric && isFinite(+r.step) && !isNaN(+r.step) && isFinite(+r.value) && !isNaN(+r.value);
          });
          const metricsInData = Array.from(new Set(cleanRows.map(r => r.metric)));
          const lcSet = new Set(metricsInData.map(m => m.toLowerCase()));
          const preferIfExists = (cand) => cand.find(c => lcSet.has(String(c).toLowerCase())) || null;
          const resolveMetric = (target) => {
            const override = providedConfig && providedConfig.metricMap && providedConfig.metricMap[target]; if (override && lcSet.has(String(override).toLowerCase())) return metricsInData.find(m => m.toLowerCase() === String(override).toLowerCase());
            const exact = metricsInData.find(m => m.toLowerCase() === target.toLowerCase()); if (exact) return exact;
            const cands = (name) => metricsInData.filter(m => m.toLowerCase().includes(name));
            if (target === 'epoch') return preferIfExists(['epoch']);
            if (target === 'train_accuracy') return preferIfExists(['train_accuracy','training_accuracy','accuracy_train','train_acc','acc_train','train/accuracy','accuracy']) || cands('acc').find(m => /train|trn/i.test(m));
            if (target === 'val_accuracy') return preferIfExists(['val_accuracy','valid_accuracy','validation_accuracy','val_acc','acc_val','val/accuracy']) || cands('acc').find(m => /val|valid/i.test(m));
            if (target === 'train_loss') return preferIfExists(['train_loss','training_loss','loss_train','train/loss','loss']) || cands('loss').find(m => /train|trn/i.test(m));
            if (target === 'val_loss') return preferIfExists(['val_loss','validation_loss','valid_loss','loss_val','val/loss']) || cands('loss').find(m => /val|valid/i.test(m));
            return null;
          };
          const TARGET_TO_DATA = Object.fromEntries(TARGET_METRICS.map(t => [t, resolveMetric(t)]));
          const metricsToDraw = TARGET_METRICS.filter(t => !!TARGET_TO_DATA[t]);

          const runList = Array.from(new Set(cleanRows.map(r => String(r.run||'').trim()).filter(Boolean))).sort();
          const palette = (() => {
            try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors==='function') return window.ColorPalettes.getColors('categorical', runList.length); } catch(_) {}
            const d = (window.d3 && window.d3.schemeTableau10) ? window.d3.schemeTableau10 : ['#7ff1ff','#5ae0e8','#3cc2da','#289ab8','#1a7e9a','#0f637b','#0a4b5e','#083948','#062a36','#041e27'];
            return d;
          })();
          const colorForRun = (name) => palette[runList.indexOf(name) % palette.length];

          const legendItemsHost = legend.querySelector('.items');
          legendItemsHost.innerHTML = runList.map((name) => { const color = colorForRun(name); return `<span class="item" data-run="${name}"><span class=\"swatch\" style=\"background:${color}\"></span><span>${name}</span></span>`; }).join('');

          const dataByMetric = new Map();
          metricsToDraw.forEach(tgt => { const m = TARGET_TO_DATA[tgt]; const map = {}; runList.forEach(r => map[r] = []); cleanRows.filter(r=>r.metric===m).forEach(r => { map[r.run].push({ step:r.step, value:r.value, stderr:r.stderr }); }); dataByMetric.set(tgt, map); });

          instances.forEach(inst => { const metricMap = dataByMetric.get(inst.metricKey) || {}; inst.render(metricMap, colorForRun); });

          const rerender = () => { instances.forEach(inst => inst.render(dataByMetric.get(inst.metricKey)||{}, colorForRun)); };
          if (window.ResizeObserver) { const ro = new ResizeObserver(() => rerender()); ro.observe(host); } else { window.addEventListener('resize', rerender); }

          legendItemsHost.querySelectorAll('.item').forEach(el => {
            el.addEventListener('mouseenter', () => { const run = el.getAttribute('data-run'); if (!run) return; host.classList.add('hovering'); host.querySelectorAll('.cell').forEach(cell => { cell.querySelectorAll('.lines path.run').forEach(p => p.classList.toggle('ghost', (p.__data__ && p.__data__.run) !== run)); cell.querySelectorAll('.points circle.pt').forEach(c => c.classList.toggle('ghost', c.getAttribute('data-run') !== run)); cell.querySelectorAll('.areas path.area').forEach(a => a.classList.toggle('ghost', a.getAttribute('data-run') !== run)); }); legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run)); });
            el.addEventListener('mouseleave', () => { host.classList.remove('hovering'); host.querySelectorAll('.cell').forEach(cell => { cell.querySelectorAll('.lines path.run').forEach(p => p.classList.remove('ghost')); cell.querySelectorAll('.points circle.pt').forEach(c => c.classList.remove('ghost')); cell.querySelectorAll('.areas path.area').forEach(a => a.classList.remove('ghost')); }); legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost')); });
          });
        } catch (e) {
          const pre = document.createElement('pre'); pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e); pre.style.color = 'var(--obl-cyan)'; pre.style.fontSize = '12px'; pre.style.whiteSpace = 'pre-wrap'; host.appendChild(pre);
        }
      })();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script>


