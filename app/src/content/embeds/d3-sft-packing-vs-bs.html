<div class="d3-sft-packing-vs-bs"></div>
<style>
  .d3-sft-packing-vs-bs {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    position: relative;
  }

  .d3-sft-packing-vs-bs svg {
    display: block;
    overflow: visible;
  }

  .d3-sft-packing-vs-bs .axes path,
  .d3-sft-packing-vs-bs .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-bs .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-packing-vs-bs .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-bs .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-sft-packing-vs-bs .line-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .d3-sft-packing-vs-bs .line-no-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .d3-sft-packing-vs-bs .line-no-packing {
    fill: none;
    stroke-width: 2;
    stroke-dasharray: 4, 4;
  }

  .d3-sft-packing-vs-bs .dot {
    stroke: var(--surface-bg);
    stroke-width: 2;
  }

  .d3-sft-packing-vs-bs .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-bs .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-bs .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-bs .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-packing-vs-bs .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-bs .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-packing-vs-bs .legend .swatch-line {
    width: 20px;
    height: 2px;
    border: none;
  }

  .d3-sft-packing-vs-bs .legend .swatch-dashed {
    width: 20px;
    height: 2px;
    border: none;
    background: repeating-linear-gradient(to right,
        var(--text-color) 0,
        var(--text-color) 4px,
        transparent 4px,
        transparent 8px);
  }

  .d3-sft-packing-vs-bs .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-bs .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-bs .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-bs .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
  }

  .d3-sft-packing-vs-bs .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-packing-vs-bs'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-packing-vs-bs'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      const CSV_PATHS = [
        '/data/sft_packing-vs-bs.csv',
        './assets/data/sft_packing-vs-bs.csv',
        '../assets/data/sft_packing-vs-bs.csv',
        '../../assets/data/sft_packing-vs-bs.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found in any of the expected locations');
      };

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        const [mx, my] = d3.pointer(event, container);
        const offsetX = 12, offsetY = 12;
        tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
        tip.style.opacity = '1';
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gDots = gRoot.append('g').attr('class', 'dots');

      let width = 800, height = 360;
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };

      // State
      let data = [];
      let benchmarks = [];
      let currentMetric = 'Average';
      let currentMode = '/no_think';

      const updateSize = () => {
        width = container.clientWidth || 800;
        height = Math.max(260, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      };

      // Get colors
      const getColors = () => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          const colors = window.ColorPalettes.getColors('categorical', 2);
          return {
            think: colors[0],
            noThink: colors[1]
          };
        }
        return {
          think: 'var(--primary-color)',
          noThink: '#7F7F7F'
        };
      };

      const render = () => {
        if (data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();
        const colors = getColors();

        // Filter data by mode
        const modeData = data.filter(d => d.mode === currentMode);

        // Separate packing data and no-packing data
        const packingData = modeData.filter(d => d.batchSize !== 'N/A');
        const noPackingData = modeData.filter(d => d.batchSize === 'N/A');

        // Get metric values
        const getMetricValue = (d) => {
          if (currentMetric === 'Average') {
            return d.average;
          }
          return d[currentMetric];
        };

        // Scales
        const batchSizes = [8, 16, 32, 64, 128];
        const xScale = d3.scalePoint()
          .domain(batchSizes)
          .range([0, innerWidth])
          .padding(0.5);

        const allValues = modeData.map(getMetricValue).filter(v => v != null);
        const yScale = d3.scaleLinear()
          .domain([0, d3.max(allValues) * 1.1 || 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid.selectAll('.grid-line').data(yScale.ticks(5))
          .join('line')
          .attr('class', 'grid-line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d));

        // Axes
        const xAxis = d3.axisBottom(xScale).tickFormat(d => d);
        const yAxis = d3.axisLeft(yScale).ticks(5);

        gAxes.selectAll('.x-axis').data([0])
          .join('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(xAxis);

        gAxes.selectAll('.y-axis').data([0])
          .join('g')
          .attr('class', 'y-axis')
          .call(yAxis);

        // Axis labels
        gAxes.selectAll('.x-label').data([0])
          .join('text')
          .attr('class', 'x-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 40)
          .text('Effective batch Size');

        gAxes.selectAll('.y-label').data([0])
          .join('text')
          .attr('class', 'y-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -48)
          .text('Score (%)');

        // Line for packing data
        const line = d3.line()
          .x(d => xScale(d.batchSize))
          .y(d => yScale(getMetricValue(d)))
          .curve(d3.curveMonotoneX);

        gLines.selectAll('.line-packing')
          .data([packingData])
          .join('path')
          .attr('class', 'line-packing')
          .attr('d', line)
          .attr('stroke', colors.think)
          .attr('stroke-width', 2.5)
          .attr('fill', 'none')
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round');

        // Horizontal line for no-packing
        if (noPackingData.length > 0) {
          const noPackingValue = getMetricValue(noPackingData[0]);
          gLines.selectAll('.line-no-packing')
            .data([noPackingValue])
            .join('line')
            .attr('class', 'line-no-packing')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', d => yScale(d))
            .attr('y2', d => yScale(d))
            .attr('stroke', colors.noThink)
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '4,4');
        } else {
          gLines.selectAll('.line-no-packing').remove();
        }

        // Dots for packing data
        gDots.selectAll('.dot')
          .data(packingData)
          .join('circle')
          .attr('class', 'dot')
          .attr('cx', d => xScale(d.batchSize))
          .attr('cy', d => yScale(getMetricValue(d)))
          .attr('r', 4)
          .attr('fill', colors.think)
          .on('mouseenter', (event, d) => {
            const value = getMetricValue(d);
            const html = `<strong>Batch Size: ${d.batchSize}</strong><br/>Score: ${value.toFixed(2)}%`;
            showTooltip(html, event);
          })
          .on('mouseleave', hideTooltip);

        // Update legend
        updateLegend(colors);
      };

      const ensureHeader = () => {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);

          // Create legend container first
          const legend = document.createElement('div');
          legend.className = 'legend';
          header.appendChild(legend);

          // Create controls container second
          const controls = document.createElement('div');
          controls.className = 'controls';
          header.appendChild(controls);
        }
        return header;
      };

      const updateLegend = (colors) => {
        const header = ensureHeader();
        let legend = header.querySelector('.legend');

        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }

        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }

        items.innerHTML = '';

        // Packing line
        const packingItem = document.createElement('span');
        packingItem.className = 'item';
        const packingSwatch = document.createElement('span');
        packingSwatch.className = 'swatch-line';
        packingSwatch.style.background = colors.think;
        const packingText = document.createElement('span');
        packingText.textContent = 'Packing';
        packingItem.appendChild(packingSwatch);
        packingItem.appendChild(packingText);
        items.appendChild(packingItem);

        // No packing line
        const noPackingItem = document.createElement('span');
        noPackingItem.className = 'item';
        const noPackingSwatch = document.createElement('span');
        noPackingSwatch.className = 'swatch-dashed';
        noPackingSwatch.style.background = `repeating-linear-gradient(to right, ${colors.noThink} 0, ${colors.noThink} 4px, transparent 4px, transparent 8px)`;
        const noPackingText = document.createElement('span');
        noPackingText.textContent = 'No packing';
        noPackingItem.appendChild(noPackingSwatch);
        noPackingItem.appendChild(noPackingText);
        items.appendChild(noPackingItem);
      };

      const buildControls = () => {
        const header = ensureHeader();
        let controls = header.querySelector('.controls');

        // Metric select
        const metricGroup = document.createElement('div');
        metricGroup.className = 'control-group';
        const metricLabel = document.createElement('label');
        metricLabel.setAttribute('for', 'metric-select-packing-bs');
        metricLabel.textContent = 'Metric';
        const metricSelect = document.createElement('select');
        metricSelect.id = 'metric-select-packing-bs';

        const metrics = ['Average', ...benchmarks];
        metrics.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m;
          if (m === currentMetric) opt.selected = true;
          metricSelect.appendChild(opt);
        });

        metricSelect.addEventListener('change', (e) => {
          currentMetric = e.target.value;
          render();
        });

        metricGroup.appendChild(metricLabel);
        metricGroup.appendChild(metricSelect);
        controls.appendChild(metricGroup);

        // Reasoning mode select
        const modeGroup = document.createElement('div');
        modeGroup.className = 'control-group';
        const modeLabel = document.createElement('label');
        modeLabel.setAttribute('for', 'mode-select-packing-bs');
        modeLabel.textContent = 'Reasoning mode';
        const modeSelect = document.createElement('select');
        modeSelect.id = 'mode-select-packing-bs';

        const modes = ['/think', '/no_think'];
        modes.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m;
          if (m === currentMode) opt.selected = true;
          modeSelect.appendChild(opt);
        });

        modeSelect.addEventListener('change', (e) => {
          currentMode = e.target.value;
          render();
        });

        modeGroup.appendChild(modeLabel);
        modeGroup.appendChild(modeSelect);
        controls.appendChild(modeGroup);
      };

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          const rows = d3.csvParse(csvText);

          // Get benchmark columns (all except Batch size and Reasoning mode)
          benchmarks = rows.columns.filter(c => c !== 'Batch size' && c !== 'Reasoning mode');

          // Parse data
          data = rows.map(row => {
            const batchSize = row['Batch size'];
            const mode = row['Reasoning mode'];
            const entry = {
              batchSize: batchSize === 'N/A' ? 'N/A' : +batchSize,
              mode: mode
            };

            // Add all benchmark values
            let sum = 0;
            let count = 0;
            benchmarks.forEach(b => {
              const val = +row[b];
              entry[b] = val;
              sum += val;
              count++;
            });

            // Calculate average
            entry.average = sum / count;

            return entry;
          });

          buildControls();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;';
          pre.textContent = 'Error loading data: ' + err.message;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>