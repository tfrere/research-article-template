<div class="d3-loss-curves"></div>
<style>
  .d3-loss-curves {
    margin-top: 20px;
    width: 100%;
    height: 350px;
    padding: 0;
    position: relative;
    overflow: hidden;
  }

  /* Ghosting on hover */
  .d3-loss-curves.hovering .lines path.ghost {
    opacity: .25 !important;
  }

  .d3-loss-curves.hovering .legend-item.ghost {
    opacity: .25 !important;
  }

  /* Tooltip styling */
  .d3-loss-curves .d3-tooltip {
    z-index: var(--z-elevated);
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-loss-curves .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 180px;
  }

  .d3-loss-curves .d3-tooltip__header {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .d3-loss-curves .d3-tooltip__color-swatch {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  .d3-loss-curves .d3-tooltip__title {
    font-weight: 800;
    letter-spacing: 0.1px;
    font-size: 13px;
  }

  .d3-loss-curves .d3-tooltip__subtitle {
    font-size: 11px;
    color: var(--muted-color);
  }

  .d3-loss-curves .d3-tooltip__divider {
    width: 100%;
    height: 1px;
    background: var(--border-color);
    margin: 2px 0;
  }

  .d3-loss-curves .d3-tooltip__data {
    font-size: 11px;
    line-height: 1.5;
  }

  /* Container styling with gradient background */
  .d3-loss-curves {
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background: radial-gradient(circle at 30% 50%, hsla(37, 99%, 67%, 0.035), transparent 40%),
      radial-gradient(circle at 60% 100%, hsla(316, 73%, 52%, 0.035), transparent 40%),
      radial-gradient(circle at 80% 40%, hsla(185, 100%, 57%, 0.035), transparent 40%),
      var(--surface-bg);
  }

  /* Hand-drawn annotation SVG */
  .d3-loss-curves .annotation {
    position: absolute;
    top: 55px;
    right: 120px;
    width: 106px;
    height: 56px;
    pointer-events: none;
  }

  .d3-loss-curves .annotation svg {
    width: 100%;
    height: 100%;
  }

  /* Text stroke styling for SVG paths */
  /* .d3-loss-curves .annotation path {
    fill: var(--text-color);
    stroke: var(--page-bg);
    stroke-width: 3px;
    stroke-linejoin: round;
    stroke-linecap: round;
    paint-order: stroke fill;
  } */

  /* Legend styling */
  .d3-loss-curves .legend {
    position: absolute;
    bottom: 16px;
    left: 20px;
    max-width: 50%;
    font-size: 11px;
    line-height: 1.2;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }

  .d3-loss-curves .legend-title {
    font-weight: 700;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--muted-color);
    margin-bottom: 4px;
  }

  .d3-loss-curves .legend-items {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .d3-loss-curves .legend-row {
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
  }

  .d3-loss-curves .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    transition: opacity 0.2s ease;
    opacity: 1;
  }

  .d3-loss-curves .legend-swatch {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  .d3-loss-curves .legend-label {
    font-size: 11px;
    color: var(--text-color);
    white-space: nowrap;
  }
</style>
<script>
  (() => {
    // Pretty label mapping for run names
    const prettyRunLabel = (key) => {
      if (!key) return '';
      // Extract the meaningful part from run names like "attention_loss+22/09/2025_16:41:43_baseline"
      const parts = key.split('+');
      if (parts.length > 1) {
        const runType = parts[0].replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        return runType;
      }
      return key.replace(/[_-]+/g, ' ').trim();
    };

    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-loss-curves'))) {
        const cs = Array.from(document.querySelectorAll('.d3-loss-curves')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // No controls needed for this visualization

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '8px 10px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Legend
      let legend = container.querySelector('.legend');
      if (!legend) {
        legend = document.createElement('div');
        legend.className = 'legend';
        container.appendChild(legend);
      }

      // Hand-drawn annotation
      let annotation = container.querySelector('.annotation');
      if (!annotation) {
        annotation = document.createElement('div');
        annotation.className = 'annotation';
        annotation.innerHTML = `

<svg width="76px" height="46px" viewBox="0 0 76 46" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="hugging-science" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group-23" transform="translate(1.000000, 0.000000)">
            <g id="Group-22" transform="translate(24.000000, 0.000000)" fill="currentColor" fill-rule="nonzero">
                <path d="M2.99305604,12.3816734 L1.98489631,11.1210802 C1.60083546,10.5480832 1.29358678,10.0132861 1.06315027,9.51668876 C0.832713755,9.02009142 0.669487893,8.40889468 0.57347268,7.68309857 C0.439051382,7.22470102 0.352637691,6.79495332 0.314231606,6.39385546 C0.27582552,5.99275761 0.261423238,5.52958508 0.27102476,5.00433789 C0.280626281,4.4790907 0.295028563,3.8249192 0.314231606,3.04182339 C0.333434648,2.31602727 0.448652903,1.71915546 0.659886372,1.25120796 C0.87111984,0.783260466 1.01514266,0.472887126 1.09195483,0.320087943 C1.49521872,-0.023710218 1.82647121,-0.0905598605 2.08571228,0.119539016 C2.34495336,0.329637892 2.53698378,0.682986003 2.66180356,1.17958335 C2.78662334,1.67618069 2.8394317,2.20142788 2.82022866,2.75532492 C2.87783779,4.79901399 3.00745832,6.34610572 3.20909027,7.3966001 C3.41072222,8.44709448 3.66516253,9.09649101 3.97241121,9.34478968 C4.19534654,9.40208937 4.39510319,9.3782145 4.57168116,9.27316506 C4.74825914,9.16811562 4.97577019,8.95801675 5.2542143,8.64286843 C5.53265842,8.32772012 5.92152003,7.91229734 6.42079914,7.3966001 C6.95848433,6.84270306 7.49616952,6.2553812 8.03385471,5.63463452 C8.57153991,5.01388784 9.08522129,4.41701603 9.57489888,3.8440191 C10.0645765,3.27102216 10.5062464,2.77554395 10.8999088,2.35758447 C11.2935712,1.93962499 11.6056206,1.66260186 11.8360571,1.52651509 C11.9128693,1.40982665 12.0472906,1.30850766 12.239321,1.22255812 C12.4313515,1.13660858 12.6185811,1.06975893 12.80101,1.02200919 C12.9834389,0.974259445 13.0746534,0.950384573 13.0746534,0.950384573 C13.2282777,0.988584368 13.3146914,1.10795873 13.3338945,1.30850766 C13.3530975,1.50905658 13.4299097,1.70483054 13.564331,1.89582952 C13.6027371,1.97222911 13.6891507,2.08682849 13.823572,2.23962768 C13.9579933,2.39242686 14.0156025,2.5165762 13.9963994,2.61207569 C13.9963994,2.66937538 13.9099857,2.79829969 13.7371584,2.99884862 C13.564331,3.19939754 13.3819021,3.3951715 13.1898716,3.58617048 C12.9978412,3.77716946 12.8538184,3.92041869 12.7578032,4.01591818 C12.5081636,4.22601705 12.119302,4.59369009 11.5912183,5.11893728 C11.0631347,5.64418447 10.5206487,6.20763146 9.96376049,6.80927824 C9.40687226,7.41092502 8.93639771,7.95049714 8.55233686,8.42799458 C7.70740299,9.40208937 6.95368357,10.2424849 6.2911786,10.9491811 C5.62867363,11.6558773 5.22060898,12.0760751 5.06698464,12.2097744 C5.0477816,12.2479742 4.92296182,12.271849 4.69252531,12.281399 C4.4620888,12.2909489 4.29886294,12.3721235 4.20284772,12.5249227 L2.99305604,12.3816734 Z M1.38000047,21.9793721 C1.3031883,21.9602722 1.1447632,21.8743227 0.904725164,21.7215235 C0.664687132,21.5687243 0.448652903,21.4254751 0.256622478,21.2917758 C0.12220118,21.1389766 0.040588249,20.9766275 0.0117836852,20.8047284 C-0.0170208786,20.6328293 0.00698292457,20.4036305 0.0837950948,20.1171321 C0.160607265,19.8306336 0.266223999,19.4295357 0.400645297,18.9138385 C0.41984834,18.4745409 0.511062792,17.9397437 0.674288654,17.3094471 C0.837514515,16.6791505 1.0343457,16.1539033 1.26478221,15.7337055 C1.26478221,15.5236066 1.31278982,15.2371082 1.40880503,14.8742101 C1.50482024,14.511312 1.62483926,14.1340891 1.76886208,13.7425412 C1.9128849,13.3509933 2.04250544,13.0119701 2.15772369,12.7254716 L2.67620584,11.2356796 L3.82838839,10.2615848 L5.32622571,11.2929793 C5.24941354,11.4075786 5.18220289,11.5412779 5.12459377,11.6940771 C5.06698464,11.8468763 4.99017247,12.1047249 4.89415726,12.467623 C4.79814204,12.830521 4.65411922,13.393968 4.4620888,14.1579639 C4.30846446,14.6736612 4.14043784,15.2275582 3.95800893,15.8196551 C3.77558003,16.4117519 3.6075534,16.9656489 3.45392906,17.4813462 C3.30030472,17.9970434 3.16588343,18.4172412 3.05066517,18.7419394 C2.82022866,19.6014348 2.61379595,20.2794812 2.43136705,20.7760785 C2.24893814,21.2726759 2.07611076,21.6116991 1.9128849,21.7931481 C1.74965904,21.9745971 1.57203089,22.0366718 1.38000047,21.9793721 Z" id="Y"></path>
                <path d="M13.4018636,21.4014426 C12.6870999,20.8820895 12.1220502,20.3963981 11.7067146,19.9443685 C11.2913789,19.4923389 11.0643931,19.0547358 11.0257573,18.6315591 C10.9871214,18.2853237 10.9919509,17.8140587 11.0402457,17.2177644 C11.0885405,16.62147 11.1513238,16.0347933 11.2285956,15.4577342 C11.3058674,14.8806751 11.3734801,14.4478808 11.4314339,14.1593513 C11.5280236,14.0631748 11.571489,13.9333365 11.56183,13.7698364 C11.5521711,13.6063363 11.5473416,13.5245863 11.5473416,13.5245863 C11.5280236,13.4284098 11.5956364,13.173542 11.7501799,12.759983 C11.9047234,12.346424 12.049608,11.8126444 12.1848335,11.1586441 C12.5711923,10.004526 12.9430626,9.03795201 13.3004444,8.25892226 C13.6578263,7.47989251 14.0103787,6.81146575 14.3581015,6.25364198 C14.7058244,5.69581821 15.0535473,5.18608269 15.4012702,4.72443543 C16.1933056,3.91655273 16.9418757,3.2721701 17.6469805,2.79128754 C18.3520852,2.31040498 19.0040656,1.93531658 19.6029217,1.66602235 C19.9892804,1.43519872 20.3466623,1.25246334 20.6750672,1.11781623 C21.0034722,0.98316911 21.2739233,0.963933808 21.4864206,1.06011032 C22.5682251,1.29093395 23.4858272,1.76219886 24.2392268,2.47390505 C24.9926264,3.18561124 25.4948927,4.21469992 25.7460259,5.56117109 C25.8812515,6.4075244 25.9633527,7.17212767 25.9923296,7.85498091 C26.0213065,8.53783414 25.9681822,9.21106973 25.8329567,9.87468766 C25.6977311,10.5383056 25.4514274,11.2644383 25.0940455,12.0530857 C24.7366637,12.8417331 24.2392268,13.7650276 23.6017348,14.8229692 C22.8096994,16.3810287 21.9452217,17.6842205 21.0083017,18.7325444 C20.0713817,19.7808684 19.1344617,20.5743246 18.1975417,21.1129131 C17.2606217,21.6515016 16.3719966,21.9448399 15.5316663,21.9929282 C14.691336,22.0410165 13.9814017,21.8438546 13.4018636,21.4014426 Z M15.7200162,19.4971477 C16.1643287,19.4394418 16.5265401,19.3528829 16.8066502,19.2374711 C17.0867603,19.1220593 17.3813588,18.9008533 17.6904458,18.5738532 C17.9995328,18.246853 18.4341864,17.7659705 18.9944066,17.1312055 C19.496673,16.5541464 19.9168382,16.0636462 20.2549021,15.6597049 C20.592966,15.2557635 20.8827351,14.8422045 21.1242093,14.4190279 C21.3656835,13.9958512 21.5974988,13.4909245 21.8196551,12.9042478 C22.0418113,12.3175711 22.288115,11.5625855 22.5585662,10.6392909 C22.7131097,10.0622319 22.8241878,9.63424638 22.8918006,9.3553345 C22.9594134,9.07642261 23.0028788,8.84079016 23.0221967,8.64843713 C23.0415146,8.45608411 23.0463441,8.1915987 23.0366851,7.85498091 C23.0270262,7.51836311 23.0221967,7.00381877 23.0221967,6.31134789 C23.0028788,5.98434774 22.935266,5.61406817 22.8193583,5.20050917 C22.7034507,4.78695017 22.5682251,4.49361181 22.4136816,4.32049408 C22.2205023,4.10890576 21.9307332,3.92617038 21.5443744,3.77228796 C21.1580157,3.61840554 20.752339,3.63764085 20.3273444,3.82999387 C20.0955291,3.92617038 19.80576,4.12333223 19.4580371,4.42147942 C19.1103143,4.71962661 18.7529324,5.07067088 18.3858916,5.47461223 C18.0188508,5.87855358 17.6711279,6.28249493 17.3427229,6.68643628 C17.014318,7.09037763 16.7535258,7.45817766 16.5603465,7.78983635 C16.3671671,8.12149504 16.2705774,8.34998939 16.2705774,8.47531941 C16.2705774,8.47531941 16.2657479,8.52340767 16.2560889,8.61958418 C16.24643,8.71576069 16.2029646,8.8119372 16.1256929,8.90811371 C15.8745597,9.17740795 15.6137675,9.6198199 15.3433164,10.2353496 C15.0728652,10.8508793 14.821732,11.5529678 14.5899168,12.3416152 C14.3581015,13.1302626 14.1649222,13.91891 14.0103787,14.7075574 C13.8558352,15.4962048 13.7592455,16.207911 13.7206096,16.842676 C13.7206096,17.1504408 13.7206096,17.4101174 13.7206096,17.6217057 C13.7206096,17.833294 13.744757,18.0208382 13.7930519,18.1843383 C13.8413467,18.3478384 13.9234479,18.5257649 14.0393556,18.718118 C14.1552632,18.910471 14.3919079,19.102824 14.7492898,19.295177 C15.1066716,19.4875301 15.4302471,19.5548536 15.7200162,19.4971477 Z" id="O"></path>
                <path d="M30.6201743,21.912 C30.1419676,21.9706667 29.7783313,22 29.5292653,22 C29.2801993,22 29.0510585,21.9706667 28.8418431,21.912 C28.6326276,21.8533333 28.358655,21.7751111 28.0199253,21.6773333 C27.7409714,21.5013333 27.4271482,21.2568889 27.0784558,20.944 C26.7297634,20.6311111 26.505604,20.4355556 26.4059776,20.3573333 C26.4059776,20.2595556 26.381071,20.1813333 26.3312578,20.1226667 C26.2814446,20.064 26.256538,20.0346667 26.256538,20.0346667 C26.1768369,20.0346667 26.1120797,19.8635556 26.0622665,19.5213333 C26.0124533,19.1791111 25.992528,18.7733333 26.0024907,18.304 C26.0124533,17.8346667 26.0423412,17.3946667 26.0921544,16.984 C26.1419676,16.5733333 26.2067248,16.2995556 26.2864259,16.1626667 C26.2864259,16.0648889 26.3113325,15.9426667 26.3611457,15.796 C26.4109589,15.6493333 26.4358655,15.5271111 26.4358655,15.4293333 C26.4358655,15.0968889 26.4856787,14.9306667 26.5853051,14.9306667 C26.5853051,14.9306667 26.6102117,14.9257778 26.6600249,14.916 C26.7098381,14.9062222 26.7347447,14.872 26.7347447,14.8133333 C26.7347447,14.696 26.7745953,14.5346667 26.8542964,14.3293333 C26.9339975,14.124 26.9937733,13.9333333 27.0336239,13.7573333 C27.1332503,13.5813333 27.2577833,13.2782222 27.4072229,12.848 C27.5566625,12.4177778 27.7011208,12.0168889 27.8405978,11.6453333 C27.9402242,11.2151111 28.0797011,10.7848889 28.2590286,10.3546667 C28.4383562,9.92444444 28.5678705,9.58222222 28.6475716,9.328 C28.9265255,8.85866667 29.0660025,8.50666667 29.0660025,8.272 C29.1058531,8.13511111 29.2403487,7.84666667 29.4694894,7.40666667 C29.6986301,6.96666667 29.9724471,6.44355556 30.2909402,5.83733333 C30.6094334,5.23111111 30.9382005,4.61511111 31.2772416,3.98933333 C31.6162827,3.36355556 31.9153176,2.81111111 32.1743462,2.332 C32.4333748,1.85288889 32.622665,1.52533333 32.7422167,1.34933333 C33.0809465,0.840888889 33.4097136,0.488888889 33.7285181,0.293333333 C34.0473225,0.0977777778 34.2963885,0 34.4757161,0 C34.5753425,0.0391111111 34.7179328,0.147659722 34.9034869,0.325645833 C35.0890411,0.503631944 35.2683686,0.694298611 35.4414695,0.897645833 C35.6145704,1.10099306 35.7110834,1.26133333 35.7310087,1.37866667 C35.7310087,1.41777778 35.6612702,1.584 35.5217933,1.87733333 C35.3823163,2.17066667 35.2029888,2.48844444 34.9838107,2.83066667 C34.7646326,3.17288889 34.5454545,3.46133333 34.3262765,3.696 C34.2665006,3.77422222 34.2316314,3.84266667 34.2216687,3.90133333 C34.2117061,3.96 34.2067248,3.98933333 34.2067248,3.98933333 C34.2067248,3.98933333 34.1419676,4.10177778 34.0124533,4.32666667 C33.882939,4.55155556 33.7285181,4.82533333 33.5491905,5.148 C33.369863,5.47066667 33.2104608,5.77866667 33.0709838,6.072 C32.9315068,6.36533333 32.8518057,6.58044444 32.8318804,6.71733333 C32.7123288,6.85422222 32.5479452,7.13288889 32.3387298,7.55333333 C32.1295143,7.97377778 31.9252802,8.42355556 31.7260274,8.90266667 C31.5267746,9.38177778 31.3474471,9.79733333 31.1880448,10.1493333 C31.0286426,10.5013333 30.9290162,10.6968889 30.8891656,10.736 C30.8891656,10.8337778 30.8841843,10.9266667 30.8742217,11.0146667 C30.864259,11.1026667 30.8194271,11.1955556 30.739726,11.2933333 C30.6799502,11.4302222 30.5753425,11.7382222 30.4259029,12.2173333 C30.2764633,12.6964444 30.0722291,13.1902222 29.8132005,13.6986667 C29.6737235,14.2853333 29.5043587,14.8035556 29.3051059,15.2533333 C29.1058531,15.7031111 28.9564134,15.9768889 28.856787,16.0746667 C28.7770859,16.2702222 28.7372354,16.3826667 28.7372354,16.412 C28.7372354,16.4413333 28.7770859,16.4462222 28.856787,16.4266667 C28.9564134,16.3288889 29.0062267,16.3142222 29.0062267,16.3826667 C29.0062267,16.4511111 28.9564134,16.5635556 28.856787,16.72 C28.7770859,16.9155556 28.732254,17.1257778 28.7222914,17.3506667 C28.7123288,17.5755556 28.7073474,17.8248889 28.7073474,18.0986667 C28.7272727,18.4897778 28.8318804,18.7831111 29.0211706,18.9786667 C29.2104608,19.1742222 29.5143213,19.272 29.9327522,19.272 C30.6102117,19.2524444 31.2029888,19.2035556 31.7110834,19.1253333 C32.2191781,19.0471111 32.6525529,18.9688889 33.011208,18.8906667 C33.6687422,18.6755556 34.241594,18.612 34.7297634,18.7 C35.2179328,18.788 35.5616438,18.9591111 35.7608966,19.2133333 C35.8804483,19.3893333 35.9501868,19.5995556 35.9701121,19.844 C35.9900374,20.0884444 36,20.2595556 36,20.3573333 C35.9402242,20.4355556 35.6961395,20.5577778 35.267746,20.724 C34.8393524,20.8902222 34.3262765,21.0613333 33.7285181,21.2373333 C33.1307597,21.4133333 32.5479452,21.5648889 31.9800747,21.692 C31.4122042,21.8191111 30.9589041,21.8924444 30.6201743,21.912 Z" id="L"></path>
                <path d="M39.8862543,19.8696487 C38.8958262,19.5064032 38.1244352,18.7846917 37.572081,17.7045143 C37.0197269,16.6243368 36.8673534,15.357757 37.1149604,13.904775 C37.1530538,13.3503476 37.2435256,12.8532748 37.3863758,12.4135565 C37.529226,11.9738383 37.6387445,11.53412 37.7149312,11.0944018 C37.7149312,11.0561654 37.7339779,10.9940313 37.7720713,10.9079995 C37.8101647,10.8219676 37.8196881,10.7407153 37.8006414,10.6642426 C37.8387348,10.5495335 37.9244449,10.3344539 38.0577717,10.0190038 C38.1910986,9.70355379 38.3244254,9.39766282 38.4577523,9.10133095 C38.5910792,8.80499909 38.6767893,8.63771497 38.7148827,8.59947859 C38.8101161,8.56124222 38.8577329,8.50866722 38.8577329,8.44175357 C38.8577329,8.37483992 38.8577329,8.3413831 38.8577329,8.3413831 C38.8577329,8.18843761 38.9624897,7.91122393 39.1720033,7.50974204 C39.3815169,7.10826015 39.6529323,6.66376235 39.9862495,6.17624863 C40.3195666,5.68873491 40.6576454,5.21555982 41.0004859,4.75672338 C41.3433264,4.29788694 41.6480735,3.91552323 41.9147272,3.60963227 C42.1813809,3.30374131 42.3528011,3.15079583 42.4289879,3.15079583 C42.486128,3.15079583 42.5337447,3.11255946 42.5718381,3.03608672 C42.6099315,2.95961398 42.6480249,2.91181851 42.6861183,2.89270033 C42.7432583,2.81622759 42.9211515,2.69995019 43.2197977,2.54386813 C43.5184439,2.38778607 43.8708077,2.22050195 44.2768892,2.04201577 C44.6829706,1.86352959 45.0860017,1.69781376 45.4859822,1.54486828 C45.8859628,1.3919228 46.2288033,1.28677278 46.5145037,1.22941822 L46.5145037,1.22941822 L46.5145037,1.22941822 C47.3525582,0.923527259 48.1049026,0.923527259 48.7715369,1.22941822 C49.4381711,1.53530918 49.9714785,2.10885474 50.3714591,2.95005488 C50.7714397,3.79125503 50.9809533,4.8618734 51,6.16190999 C50.9238132,6.58251006 50.8809582,6.9792124 50.8714348,7.35201701 C50.8619115,7.72482162 50.8285798,7.99725576 50.7714397,8.16931943 C50.752393,8.5899195 50.6857296,9.06787413 50.5714494,9.60318332 C50.4571692,10.1384925 50.3428891,10.6021085 50.2286089,10.9940313 C50.1143287,11.3859541 50.0286186,11.5914746 49.9714785,11.6105928 C49.9714785,11.6870655 49.9524319,11.7587587 49.9143385,11.8256723 C49.8762451,11.892586 49.8571984,11.9547201 49.8571984,12.0120746 C49.8762451,12.1076656 49.8095817,12.3275247 49.6572081,12.671652 C49.5048346,13.0157794 49.323891,13.3981431 49.1143773,13.8187431 C48.9048637,14.2393432 48.7143968,14.6025887 48.5429765,14.9084797 C48.3715563,15.2143707 48.2667995,15.3673161 48.2287061,15.3673161 C48.2287061,15.3673161 48.2096594,15.3720957 48.171566,15.3816548 C48.1334726,15.3912139 48.1239493,15.4342298 48.142996,15.5107025 C48.1620427,15.5489389 48.0953792,15.6445298 47.9430057,15.7974753 C47.7906321,15.9504208 47.6239736,16.0985867 47.44303,16.2419731 C47.2620864,16.3853595 47.1239979,16.4570527 47.0287644,16.4570527 C47.0287644,16.4570527 47.0144794,16.4666118 46.9859093,16.48573 C46.9573393,16.5048482 46.9716243,16.5430845 47.0287644,16.6004391 C47.0478111,16.6386754 46.9001992,16.7868414 46.5859288,17.0449369 C46.2716583,17.3030324 45.8764394,17.5993643 45.4002721,17.9339325 C44.9241048,18.2685007 44.4479374,18.5743917 43.9717701,18.8516054 C43.4956027,19.1288191 43.1146689,19.2961032 42.8289685,19.3534577 C42.7718284,19.4299305 42.7146883,19.4729464 42.6575482,19.4825055 C42.6004081,19.4920646 42.5242214,19.5064032 42.4289879,19.5255214 C42.295661,19.6593487 42.0623391,19.7692783 41.7290219,19.8553101 C41.3957048,19.9413419 41.057626,19.9891374 40.7147855,19.9986965 C40.371945,20.0082556 40.0957679,19.9652397 39.8862543,19.8696487 Z M42.7718284,16.8585346 C43.1527623,16.7247073 43.5384578,16.538305 43.928915,16.2993277 C44.3193722,16.0603503 44.6622127,15.8022548 44.9574365,15.5250412 C45.2526602,15.2478275 45.4383655,14.9849524 45.5145523,14.736416 C45.5716923,14.526116 45.6335941,14.368391 45.7002575,14.2632409 C45.7669209,14.1580909 45.838346,14.0768386 45.9145328,14.0194841 C46.0669064,13.8665386 46.262135,13.5797658 46.5002186,13.1591658 C46.7383023,12.7385657 46.9716243,12.2797292 47.2001846,11.7826564 C47.428745,11.2855836 47.6239736,10.8124085 47.7858705,10.3631312 C47.9477674,9.91385382 48.0382392,9.58406513 48.0572858,9.37376509 C48.0572858,9.33552872 48.0858559,9.17302415 48.142996,8.88625137 C48.200136,8.59947859 48.2667995,8.38917856 48.3429862,8.25535126 C48.3810796,8.17887852 48.3953647,8.10718533 48.3858413,8.04027168 C48.376318,7.97335803 48.3667946,7.77739663 48.3572713,7.45238749 C48.3477479,7.12737834 48.3525096,6.54427369 48.3715563,5.70307355 C48.3525096,5.01481888 48.2906078,4.50340743 48.185851,4.16883919 C48.0810942,3.83427095 47.952529,3.62875046 47.8001555,3.55227772 L47.8001555,3.55227772 L47.8001555,3.55227772 C47.7620621,3.51404135 47.6715903,3.47580498 47.5287401,3.43756861 C47.3858899,3.39933224 47.238278,3.3754345 47.0859045,3.36587541 C46.9335309,3.35631632 46.7906807,3.38021405 46.6573539,3.43756861 C46.5621204,3.45668679 46.4335552,3.49970271 46.2716583,3.56661636 C46.1097614,3.63353 45.9716729,3.66698683 45.8573927,3.66698683 C45.7050192,3.74345957 45.6002624,3.83658604 45.5431223,3.94636624 C45.4859822,4.05614645 45.4574122,4.13836958 45.4574122,4.19303564 C45.4574122,4.33940925 45.3907487,4.47473015 45.2574219,4.59899835 C45.124095,4.72326656 44.9717215,4.7376052 44.8003012,4.64201427 C44.4955542,4.66113246 44.2908022,4.69936883 44.1860454,4.75672338 C44.0812886,4.81407794 43.9860551,4.93356659 43.900345,5.11518935 C43.8146349,5.29681211 43.6479763,5.59792353 43.4003693,6.0185236 C42.8670619,6.43912367 42.486128,6.85016465 42.2575677,7.25164654 C42.0290073,7.65312843 41.8956805,7.95901939 41.8575871,8.16931943 C41.4576065,8.89581046 41.1623828,9.45501738 40.9719158,9.84694018 C40.7814489,10.238863 40.6505029,10.5877698 40.5790778,10.8936608 C40.5076527,11.1995518 40.4481318,11.5723564 40.400515,12.0120746 C40.2290948,12.3370838 40.1052913,12.6812111 40.0291045,13.0444566 C39.9529177,13.4077022 39.8862543,13.6466795 39.8291142,13.7613886 C39.7910208,13.8569795 39.7719742,14.0338227 39.7719742,14.2919182 C39.7719742,14.5500137 39.7862592,14.8367865 39.8148292,15.1522366 C39.8433993,15.4676866 39.8814926,15.7544594 39.9291094,16.0125549 C39.9767261,16.2706504 40.0291045,16.4570527 40.0862446,16.5717618 C40.2005248,17.0114801 40.4767018,17.2600165 40.9147758,17.317371 C41.3528497,17.3747256 41.9718673,17.2217801 42.7718284,16.8585346 Z" id="O"></path>
            </g>
            <g id="Group" transform="translate(0.000000, 28.000000)" stroke="currentColor" stroke-linecap="round" stroke-width="2">
                <path d="M16,0 C12.6666667,2.66666667 9.66666667,5.66666667 7,9 C5.66666667,11.6666667 4.33333333,14.3333333 3,17" id="Path" stroke-linejoin="round"></path>
                <path d="M3,17 L0,10 M3,17 L9,14" id="Shape"></path>
            </g>
        </g>
    </g>
</svg>

        `;
        container.appendChild(annotation);
      }

      // ============ CONFIGURATION ============
      // Visualization mode: 'normalize' | 'align' | 'raw'
      //
      // 'normalize' (CURRENT) ✅
      //   → Each run starts at X=0 (relative to its own start)
      //   → Runs have different lengths (based on their training duration)
      //   → No data removed
      //   → Ideal for comparing curve shapes
      //
      // 'align'
      //   → All runs start at the same absolute point (latest start)
      //   → All runs end at the same absolute point (earliest end)
      //   → Same length for all runs (trimmed)
      //   → Data trimmed for alignment
      //   → Ideal for comparing over a common time window
      //
      // 'raw'
      //   → Displays raw data without transformation
      //   → Each run keeps its original start and end points
      //   → No normalization
      //   → Ideal for seeing real training timelines
      //
      const VISUALIZATION_MODE = 'align';

      // Log scale control: true = logarithmic, false = linear
      const USE_LOG_SCALE = true;

      // Gap between run groups: 0.2 = doubled gap, 0.1 = normal gap
      const CATEGORY_GAP = 0.05;
      // =======================================

      // State/data
      const svgPaddingTop = 20;
      const svgPaddingBottom = 20;
      const svgHeight = 330;
      const contentHeight = svgHeight - svgPaddingTop - svgPaddingBottom;
      let width = 800, height = svgHeight; const margin = { top: 0, right: 0, bottom: 0, left: 0 };

      // SVG container
      const svg = d3.select(container).append('svg').attr('width', 800).attr('height', svgHeight).style('display', 'block');
      const gRoot = svg.append('g').attr('transform', `translate(0, ${svgPaddingTop})`);
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gPoints = gRoot.append('g').attr('class', 'points');
      const overlay = gRoot.append('rect').attr('fill', 'transparent').style('cursor', 'crosshair');
      const hoverLine = gRoot.append('line').attr('stroke-width', 1).style('display', 'none');
      const xScale = USE_LOG_SCALE ? d3.scaleLinear() : d3.scaleLinear();
      const yScale = USE_LOG_SCALE ? d3.scaleLinear() : d3.scaleLinear();
      const lineGen = d3.line().x(d => xScale(d.logTokens)).y(d => yScale(d.logLoss));
      const dataByRun = new Map();
      let runOrder = [];

      // Colors - categorical for distinct run categories
      function getRunColors(count) {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            return window.ColorPalettes.getColors('categorical', count);
          }
        } catch (_) { }
        // Fallback to categorical-like colors - evenly distributed hues
        const colors = [];
        for (let i = 0; i < count; i++) {
          const hue = (i * 360 / count) % 360;
          colors.push(`hsl(${hue}, 70%, 60%)`);
        }
        return colors;
      }

      // Format helper for thousands (5000 -> 5k, 1500 -> 1.5k)
      function formatK(v) {
        const abs = Math.abs(v);
        if (abs >= 1000) {
          const n = v / 1000;
          const s = d3.format('.1f')(n);
          return (s.endsWith('.0') ? s.slice(0, -2) : s) + 'k';
        }
        return d3.format('d')(v);
      }

      // Format numbers with K/M/B suffixes
      function formatNumber(num) {
        if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
        if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
        if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
        return num.toFixed(0);
      }

      // Parse run name to extract type and config
      function parseRunName(runName) {
        // Format: "category_loss+date_time_config"
        const parts = runName.split('+');
        const category = parts[0] || '';
        const configPart = parts[1] || '';

        // Extract readable category name
        const categoryName = category.replace(/_loss$/i, '').replace(/_/g, ' ')
          .replace(/\b\w/g, l => l.toUpperCase());

        // Remove date/time part (format: DD/MM/YYYY_HH:MM:SS_)
        // This will match patterns like "22/09/2025_16:41:43_"
        let config = configPart.replace(/^\d{2}\/\d{2}\/\d{4}_\d{2}:\d{2}:\d{2}_/, '');

        // Check if it was baseline before removing it
        const wasBaseline = /^baseline$/i.test(config) || /^baseline[-_]/i.test(config) || /[-_]baseline$/i.test(config);

        // Remove "baseline" (case insensitive)
        config = config.replace(/^baseline$/i, '').replace(/^baseline[-_]/i, '').replace(/[-_]baseline$/i, '');

        // Clean up and format if something remains
        if (config) {
          config = config.replace(/[_-]+/g, ' ').trim()
            .replace(/\b\w/g, l => l.toUpperCase());
        } else if (wasBaseline) {
          // If nothing remains but it was baseline, show "Baseline"
          config = 'Baseline';
        }

        return { categoryName, config };
      }

      // Helper function to check if a run is a true baseline (nothing after "baseline")
      function isBaselineRun(runName) {
        const parts = runName.split('+');
        if (parts.length < 2) return false;
        const configPart = parts[1] || '';
        // Remove date/time part first (format: DD/MM/YYYY_HH:MM:SS_)
        let config = configPart.replace(/^\d{2}\/\d{2}\/\d{4}_\d{2}:\d{2}:\d{2}_/, '');
        // Check if it's exactly "baseline" (case insensitive) with nothing after
        return /^baseline$/i.test(config);
      }

      // Helper function to saturate a color slightly
      function saturateColor(color) {
        // Handle different color formats
        if (color.startsWith('hsl(')) {
          // HSL color - boost saturation slightly and reduce lightness a bit
          const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
          if (match) {
            const h = parseInt(match[1]);
            const s = Math.min(100, parseInt(match[2]) + 25); // +10% saturation
            const l = Math.max(0, parseInt(match[3]));    // -5% lightness
            return `hsl(${h}, ${s}%, ${l}%)`;
          }
        } else if (color.startsWith('#')) {
          // Convert hex to RGB then to HSL
          const hex = color.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16) / 255;
          const g = parseInt(hex.substr(2, 2), 16) / 255;
          const b = parseInt(hex.substr(4, 2), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
              case g: h = ((b - r) / d + 2) / 6; break;
              case b: h = ((r - g) / d + 4) / 6; break;
            }
          }

          h = Math.round(h * 360);
          s = Math.min(100, Math.round(s * 100) + 10);
          l = Math.max(0, Math.round(l * 100) - 5);

          return `hsl(${h}, ${s}%, ${l}%)`;
        }
        // Fallback: return original color
        return color;
      }

      // Single aggregated CSV file
      const AGGREGATED_CSV = 'aggregated-loss-data.csv';

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            // Add timestamp to bypass cache
            const url = p + (p.includes('?') ? '&' : '?') + '_=' + Date.now();
            const r = await fetch(url, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found');
      };

      // ============ DATA TRANSFORMATION MODES ============
      /**
       * Transform data according to the selected visualization mode
       * @param {Map} dataByRun - Map(run_name -> array of {tokens, loss, logTokens, logLoss})
       * @param {string} mode - 'normalize' | 'align' | 'raw'
       * @returns {Map} Transformed data
       */
      function transformDataByMode(dataByRun, mode) {
        const runs = Array.from(dataByRun.keys());
        const transformedData = new Map();

        if (mode === 'normalize') {
          // NORMALIZE MODE: Each run starts at X=0 (relative to its start)
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              const firstLogTokens = Math.min(...data.map(d => d.logTokens));
              const normalizedData = data.map(d => ({
                ...d,
                logTokens: d.logTokens - firstLogTokens
              }));
              transformedData.set(r, normalizedData);
            }
          });

        } else if (mode === 'align') {
          // ALIGN MODE: Improved alignment strategy
          // 1. Collect all start and end points
          const runRanges = [];
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              const minTokens = Math.min(...data.map(d => d.logTokens));
              const maxTokens = Math.max(...data.map(d => d.logTokens));
              runRanges.push({ run: r, min: minTokens, max: maxTokens, data });
            }
          });

          if (runRanges.length === 0) return transformedData;

          // 2. Use percentile-based alignment (70th percentile start, 30th percentile end)
          // This gives a better balance than strict min/max
          const starts = runRanges.map(r => r.min).sort((a, b) => a - b);
          const ends = runRanges.map(r => r.max).sort((a, b) => a - b);

          const startPercentile = Math.floor(starts.length * 0.3); // Use 30th percentile as start
          const endPercentile = Math.floor(ends.length * 0.8);    // Use 80th percentile as end

          const alignedStart = starts[Math.max(0, startPercentile)];
          const alignedEnd = ends[Math.min(ends.length - 1, endPercentile)];

          // 3. Filter and align data
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              // Filter to alignment window but be more permissive
              const filtered = data.filter(d =>
                d.logTokens >= alignedStart && d.logTokens <= alignedEnd
              );

              // If we have very little data after filtering, be more lenient
              let finalData = filtered;
              if (filtered.length < 3) {
                // Fallback: use data that intersects with the alignment window
                finalData = data.filter(d => d.logTokens >= alignedStart);
                // Take at least 80% of the run's original length or minimum viable amount
                if (finalData.length < Math.max(3, data.length * 0.8)) {
                  finalData = data; // If still too restrictive, use all data
                }
                // But still normalize to the alignment start
              }

              if (finalData.length > 0) {
                const alignedData = finalData.map(d => ({
                  ...d,
                  logTokens: d.logTokens - alignedStart
                }));
                transformedData.set(r, alignedData);
              }
            }
          });

        } else {
          // RAW MODE: Raw data without transformation
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              transformedData.set(r, [...data]); // Deep copy
            }
          });
        }

        return transformedData;
      }
      // ==================================================

      function updateLayout() {
        const axisColor = getComputedStyle(container).getPropertyValue('--axis-color').trim() || 'rgba(0,0,0,0.25)';
        width = container.clientWidth || 800;
        height = svgHeight;
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(0, ${svgPaddingTop})`);
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = contentHeight;
        overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);
        hoverLine.attr('y1', 0).attr('y2', innerHeight).attr('stroke', axisColor);
        return { innerWidth, innerHeight };
      }

      function render() {
        const { innerWidth, innerHeight } = updateLayout();

        // Transform data according to selected mode
        const transformedData = transformDataByMode(dataByRun, VISUALIZATION_MODE);
        const allRuns = Array.from(transformedData.keys()).sort();
        // Filter out debug runs
        const runs = allRuns.filter(run =>
          !run.toLowerCase().includes('debug') &&
          !run.toLowerCase().includes('tp debug') &&
          !run.toLowerCase().includes('tp-debug') &&
          !run.toLowerCase().includes('test')
        );

        // Compute domains from transformed data
        let minLogTokens = Infinity, maxLogTokens = -Infinity;
        let minLogLoss = Infinity, maxLogLoss = -Infinity;

        runs.forEach(r => {
          const data = transformedData.get(r) || [];
          data.forEach(d => {
            minLogTokens = Math.min(minLogTokens, d.logTokens);
            maxLogTokens = Math.max(maxLogTokens, d.logTokens);
            minLogLoss = Math.min(minLogLoss, d.logLoss);
            maxLogLoss = Math.max(maxLogLoss, d.logLoss);
          });
        });

        // No grid or axes - clean visualization
        gGrid.selectAll('*').remove();
        gAxes.selectAll('*').remove();

        // Lines with vertical offset - optimized
        // Group runs by category (prefix before '+')
        const categoryMap = new Map();
        const categories = [];
        runs.forEach(r => {
          const parts = r.split('+');
          const category = parts.length > 1 ? parts[0] : r;
          if (!categoryMap.has(category)) {
            categories.push(category);
            categoryMap.set(category, []);
          }
          categoryMap.get(category).push(r);
        });

        // Generate one color per category
        const categoryColors = getRunColors(categories.length);
        const runColorMap = {};
        categories.forEach((cat, idx) => {
          const color = categoryColors[idx];
          categoryMap.get(cat).forEach(run => {
            runColorMap[run] = color;
          });
        });

        // Split categories into two rows (5 on top, 6 on bottom for 11 items)
        const midPoint = Math.floor(categories.length / 2);
        const firstRow = categories.slice(0, midPoint);
        const secondRow = categories.slice(midPoint);

        const createRow = (cats, startIdx) => cats.map((cat, i) => {
          const idx = startIdx + i;
          const prettyLabel = cat.replace(/_/g, ' ').replace(/loss/g, '').trim()
            .replace(/\b\w/g, l => l.toUpperCase());
          return `
            <div class="legend-item" data-category="${cat}">
              <div class="legend-swatch" style="background: ${categoryColors[idx]}"></div>
              <div class="legend-label">${prettyLabel}</div>
            </div>
          `;
        }).join('');

        // Update legend with two rows
        legend.innerHTML = `
          <div class="legend-title">Run Types</div>
          <div class="legend-items">
            <div class="legend-row">${createRow(firstRow, 0)}</div>
            <div class="legend-row">${createRow(secondRow, midPoint)}</div>
          </div>
        `;

        // Legend interaction - highlight category on hover
        legend.querySelectorAll('.legend-item').forEach(item => {
          const cat = item.getAttribute('data-category');
          item.addEventListener('mouseenter', () => {
            container.classList.add('hovering');
            // Ghost lines (both dashed and solid)
            gLines.selectAll('path.run').classed('ghost', function (d) {
              const parts = d.run.split('+');
              const runCat = parts.length > 1 ? parts[0] : d.run;
              return runCat !== cat;
            });
            gLines.selectAll('path.baseline-solid').classed('ghost', function (d) {
              const parts = d.run.split('+');
              const runCat = parts.length > 1 ? parts[0] : d.run;
              return runCat !== cat;
            });
            // Ghost legend items
            legend.querySelectorAll('.legend-item').forEach(otherItem => {
              if (otherItem.getAttribute('data-category') !== cat) {
                otherItem.classList.add('ghost');
              }
            });
          });
          item.addEventListener('mouseleave', () => {
            container.classList.remove('hovering');
            gLines.selectAll('path.run').classed('ghost', false);
            gLines.selectAll('path.baseline-solid').classed('ghost', false);
            legend.querySelectorAll('.legend-item').forEach(otherItem => {
              otherItem.classList.remove('ghost');
            });
          });
        });

        // Create vertical offset mapping with doubled gaps between categories
        const createVerticalOffsetMap = () => {
          const runToOffset = new Map();
          let runIndex = 0;

          categories.forEach((category, catIndex) => {
            const categoryRuns = categoryMap.get(category);
            categoryRuns.forEach(run => {
              // Gap between categories + normal run spacing (runIndex * 0.05)
              const verticalOffset = (catIndex * CATEGORY_GAP) + (runIndex * 0.05);
              runToOffset.set(run, verticalOffset);
              runIndex++;
            });
          });

          return runToOffset;
        };

        const verticalOffsetMap = createVerticalOffsetMap();

        // Calculate max vertical offset for padding
        let maxVerticalOffset = 0;
        for (const offset of verticalOffsetMap.values()) {
          maxVerticalOffset = Math.max(maxVerticalOffset, offset);
        }
        maxLogLoss += maxVerticalOffset;

        // Update scales with final domain
        xScale.domain([minLogTokens, maxLogTokens]).range([0, innerWidth]);
        yScale.domain([minLogLoss, maxLogLoss]).range([innerHeight, 0]);

        const series = runs.map((r) => {
          const data = transformedData.get(r) || [];
          // Sample data for performance - take every 5th point
          const sampledData = data.filter((_, idx) => idx % 5 === 0);
          return {
            run: r,
            color: runColorMap[r],
            values: sampledData.sort((a, b) => a.logTokens - b.logTokens).map(d => ({
              ...d,
              logLoss: d.logLoss + verticalOffsetMap.get(r) // Vertical offset with doubled category gaps
            }))
          };
        });

        // First, add solid lines under dashed baseline lines (background)
        const baselineSeries = series.filter(s => isBaselineRun(s.run));
        if (baselineSeries.length > 0) {
          const solidPaths = gLines.selectAll('path.baseline-solid').data(baselineSeries, d => `solid-${d.run}`);
          const solidPathsEnter = solidPaths.enter().append('path')
            .attr('class', 'baseline-solid')
            .attr('fill', 'none')
            .attr('stroke-width', 3)
            .attr('stroke', d => d.color)
            .attr('stroke-dasharray', null)
            .attr('d', d => lineGen(d.values));

          solidPathsEnter.merge(solidPaths)
            .attr('stroke', d => d.color)
            .attr('d', d => lineGen(d.values));
          solidPaths.exit().remove();
        }

        // Then, add all lines (saturated baselines will be on top)
        const paths = gLines.selectAll('path.run').data(series, d => d.run);
        const pathsEnter = paths.enter().append('path')
          .attr('class', 'run')
          .attr('fill', 'none')
          .attr('stroke-width', 2)
          .attr('stroke', d => isBaselineRun(d.run) ? saturateColor(d.color) : d.color)
          .attr('stroke-dasharray', null)
          .attr('d', d => lineGen(d.values));

        pathsEnter.merge(paths)
          .attr('stroke', d => isBaselineRun(d.run) ? saturateColor(d.color) : d.color)
          .attr('stroke-dasharray', null)
          .attr('d', d => lineGen(d.values)); // No transition for performance
        paths.exit().remove();

        // Hover capture paths (wider invisible stroke for easy hovering) - optimized
        const captures = gLines.selectAll('path.run-hover').data(series, d => `cap-${d.run}`);
        captures.enter().append('path').attr('class', 'run-hover').attr('fill', 'none').attr('stroke', 'transparent').attr('stroke-width', 12).style('pointer-events', 'stroke')
          .attr('d', d => lineGen(d.values))
          .merge(captures)
          .attr('d', d => lineGen(d.values))
          .on('mouseenter', function (ev, d) {
            container.classList.add('hovering');
            // Ghost non-hovered lines (both dashed and solid)
            gLines.selectAll('path.run').classed('ghost', s => s.run !== d.run);
            gLines.selectAll('path.baseline-solid').classed('ghost', s => s.run !== d.run);
          })
          .on('mouseleave', function () {
            container.classList.remove('hovering');
            gLines.selectAll('path.run').classed('ghost', false);
            gLines.selectAll('path.baseline-solid').classed('ghost', false);
          });
        captures.exit().remove();

        // No point markers - just lines

        // No legend needed

        // Hover interaction - optimized
        function onMove(ev) {
          const [mx, my] = d3.pointer(ev, overlay.node());

          // Find nearest point on any line - optimized search
          let nearestPoint = null;
          let minDist = Infinity;
          const threshold = 20;

          for (const s of series) {
            for (const pt of s.values) {
              const dist = Math.abs(xScale(pt.logTokens) - mx); // Only check X distance first
              if (dist < threshold && dist < minDist) {
                const yDist = Math.abs(yScale(pt.logLoss) - my);
                const totalDist = Math.sqrt(dist * dist + yDist * yDist);
                if (totalDist < minDist) {
                  minDist = totalDist;
                  nearestPoint = { ...pt, run: s.run, color: s.color };
                }
              }
            }
          }

          if (nearestPoint && minDist < threshold) {
            // Parse run info
            const { categoryName, config } = parseRunName(nearestPoint.run);

            // Format metrics
            const tokensFormatted = formatNumber(nearestPoint.tokens);
            const lossFormatted = nearestPoint.loss.toFixed(2);

            // Build rich tooltip with color swatch
            let html = `
              <div class="d3-tooltip__header">
                <div class="d3-tooltip__color-swatch" style="background: ${nearestPoint.color}"></div>
                <div class="d3-tooltip__title">${categoryName}</div>
              </div>
            `;

            // Only show config if it exists
            if (config) {
              html += `<div class="d3-tooltip__subtitle">Config: ${config}</div>`;
            }

            html += `
              <div class="d3-tooltip__divider"></div>
              <div class="d3-tooltip__data">
                Tokens: ${tokensFormatted}<br/>
                Loss: ${lossFormatted}
              </div>
            `;

            tipInner.innerHTML = html;
            tip.style.opacity = '1';

            // Ghost other lines (both dashed and solid)
            container.classList.add('hovering');
            gLines.selectAll('path.run').classed('ghost', s => s.run !== nearestPoint.run);
            gLines.selectAll('path.baseline-solid').classed('ghost', s => s.run !== nearestPoint.run);

            // Smart positioning - keep tooltip within container bounds
            const tooltipRect = tip.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            const offset = 12;
            let x = mx + margin.left + offset;
            let y = my + margin.top + offset;

            // Check right edge
            if (x + tooltipRect.width > containerRect.width) {
              x = mx + margin.left - tooltipRect.width - offset;
            }

            // Check bottom edge
            if (y + tooltipRect.height > containerRect.height) {
              y = my + margin.top - tooltipRect.height - offset;
            }

            // Check left edge (if flipped to left)
            if (x < 0) {
              x = offset;
            }

            // Check top edge (if flipped to top)
            if (y < 0) {
              y = offset;
            }

            tip.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
          } else {
            tip.style.opacity = '0';
            container.classList.remove('hovering');
            gLines.selectAll('path.run').classed('ghost', false);
            gLines.selectAll('path.baseline-solid').classed('ghost', false);
          }
        }
        function onLeave() {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          container.classList.remove('hovering');
          gLines.selectAll('path.run').classed('ghost', false);
          gLines.selectAll('path.baseline-solid').classed('ghost', false);
        }
        overlay.on('mousemove', onMove).on('mouseleave', onLeave);
      }

      // Load aggregated CSV file and initialize
      (async () => {
        try {
          // Load single aggregated CSV file
          const paths = [
            `/data/${AGGREGATED_CSV}`,
            `./assets/data/${AGGREGATED_CSV}`,
            `../assets/data/${AGGREGATED_CSV}`,
            `../../assets/data/${AGGREGATED_CSV}`
          ];

          const text = await fetchFirstAvailable(paths);

          // Parse CSV - format is run_name,tokens,loss with prefixes already included
          const rows = d3.csvParse(text, d => ({
            run: (d.run_name || '').trim(),
            tokens: +d.tokens,
            loss: +d.loss
          }));

          // Filter out invalid data and compute log values
          const allData = rows
            .filter(r => r.run && r.tokens > 0 && r.loss > 0) // Valid data only
            .map(row => ({
              run: row.run,
              tokens: row.tokens,
              loss: row.loss,
              logTokens: USE_LOG_SCALE ? Math.log(row.tokens) : row.tokens,
              logLoss: USE_LOG_SCALE ? Math.log(row.loss) : row.loss
            }));

          // Group data by run
          runOrder = Array.from(new Set(allData.map(r => r.run))).sort();
          runOrder.forEach(r => {
            dataByRun.set(r, allData.filter(d => d.run === r));
          });

          render();
          const rerender = () => render();
          if (window.ResizeObserver) { const ro = new ResizeObserver(() => rerender()); ro.observe(container); } else { window.addEventListener('resize', rerender); }
        } catch (e) {
          const pre = document.createElement('pre'); pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)'; pre.style.fontSize = '12px'; pre.style.whiteSpace = 'pre-wrap'; container.appendChild(pre);
        }
      })();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script>