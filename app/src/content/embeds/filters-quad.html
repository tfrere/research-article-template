<div class="filters-quad" style="width:100%;margin:10px 0;">
  <div class="filters-quad__controls" aria-label="Global chart controls"></div>
  <div class="filters-quad__legend" aria-label="Global legend"></div>
  <div class="filters-quad__grid">
    <div class="quad-cell" data-title="Formatting Filter" data-csv="/data/formatting_filters.csv"></div>
    <div class="quad-cell" data-title="Relevance Filter" data-csv="/data/relevance_filters.csv"></div>
    <div class="quad-cell" data-title="Visual Dependency Filter" data-csv="/data/visual_dependency_filters.csv"></div>
    <div class="quad-cell" data-title="Image Correspondence Filter" data-csv="/data/image_correspondence_filters.csv"></div>
  </div>
  <noscript>JavaScript is required to render these charts.</noscript>
</div>
<style>
  .filters-quad { position: relative; }
  .filters-quad__grid { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
  @media (max-width: 980px) { .filters-quad__grid { grid-template-columns: 1fr; } }

  .filters-quad__controls { display:flex; align-items:center; justify-content:center; gap:12px; margin: 6px 0 12px 0; flex-wrap:wrap; }
  .filters-quad__controls label { font-size:14px; color: var(--text-color); font-weight:600; display:flex; align-items:center; gap:8px; }
  .filters-quad__controls select {
    font-size: 14px; padding: 8px 32px 8px 12px; border: 1px solid var(--border-color); border-radius: 10px;
    background-color: var(--surface-bg); color: var(--text-color);
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%230f1115' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 8px center; background-size: 12px; -webkit-appearance: none; appearance: none; cursor: pointer; transition: border-color .15s ease, box-shadow .15s ease;
  }
  [data-theme="dark"] .filters-quad__controls select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
  }
  .filters-quad__controls select:hover { border-color: var(--primary-color); }
  .filters-quad__controls select:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(232,137,171,.25); outline: none; }

  .filters-quad__legend { display:flex; align-items:center; justify-content:center; gap:12px; flex-wrap:wrap; font-size:12px; color: var(--text-color); margin: 2px 0 10px 0; }
  .filters-quad__legend .item { display:inline-flex; align-items:center; gap:6px; white-space:nowrap; }
  .filters-quad__legend .swatch { width:10px; height:10px; border-radius:50%; display:inline-block; }

  .quad-cell { border:1px solid var(--border-color); border-radius:10px; background: var(--surface-bg); display:flex; flex-direction:column; position: relative; }
  /* Stacking order to ensure hover/tooltip overlays are not hidden by neighbors */
  .filters-quad__grid .quad-cell:nth-child(1) { z-index: 4; } /* top-left */
  .filters-quad__grid .quad-cell:nth-child(3) { z-index: 3; } /* bottom-left */
  .filters-quad__grid .quad-cell:nth-child(2) { z-index: 2; } /* top-right */
  .filters-quad__grid .quad-cell:nth-child(4) { z-index: 1; } /* bottom-right */
  .quad-cell .cell-header { padding:8px 10px; border-bottom:1px solid var(--border-color); display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .quad-cell .cell-title { font-size: 13px; font-weight: 700; color: var(--text-color); }
  .quad-cell .cell-controls { display:flex; align-items:center; gap:12px; }
  .quad-cell .cell-controls label { font-size:12px; color: var(--muted-color); display:flex; align-items:center; gap:6px; white-space:nowrap; }
  .quad-cell select {
    font-size: 12px; padding: 6px 28px 6px 10px; border: 1px solid var(--border-color); border-radius: 8px;
    background-color: var(--surface-bg); color: var(--text-color);
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%230f1115' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
    background-repeat: no-repeat; background-position: right 8px center; background-size: 12px;
    -webkit-appearance: none; appearance: none; cursor: pointer; transition: border-color .15s ease, box-shadow .15s ease;
  }
  [data-theme="dark"] .quad-cell select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
  }
  .quad-cell select:hover { border-color: var(--primary-color); }
  .quad-cell select:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(232,137,171,.25); outline: none; }
  .quad-cell .cell-body { position: relative; }
  .quad-cell .cell-body { width:100%; overflow:hidden; }
  .quad-cell .cell-body svg { max-width:100%; height:auto; }
  .quad-cell .legend { font-size: 12px; line-height: 1.35; color: var(--text-color); }
  .quad-cell .legend .items { display:flex; flex-wrap:wrap; gap:8px 12px; align-items:center; justify-content:flex-end; }
  .quad-cell .legend .item { display:flex; align-items:center; gap:6px; white-space:nowrap; }
  .quad-cell .legend .swatch { width:10px; height:10px; border-radius:50%; display:inline-block; }
</style>
<script>
  (() => {
    const THIS_SCRIPT = document.currentScript;
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    function initRunLine(cell){
      const d3 = window.d3;
      const csvPath = cell.getAttribute('data-csv');
      const titleText = cell.getAttribute('data-title') || '';

      // Header
      const header = document.createElement('div'); header.className = 'cell-header';
      const title = document.createElement('div'); title.className = 'cell-title'; title.textContent = titleText; header.appendChild(title);
      // Per-cell controls supprimés (contrôle global utilisé)
      cell.appendChild(header);

      // Body & SVG
      const body = document.createElement('div'); body.className = 'cell-body'; cell.appendChild(body);
      const svg = d3.select(body).append('svg').attr('width','100%').style('display','block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class','grid');
      const gAxes = gRoot.append('g').attr('class','axes');
      const gAreas = gRoot.append('g').attr('class','areas');
      const gLines = gRoot.append('g').attr('class','lines');
      const gPoints = gRoot.append('g').attr('class','points');
      const gHover = gRoot.append('g').attr('class','hover');
      const gLegend = gRoot.append('foreignObject').attr('class','legend').style('display','none');

      // Tooltip
      cell.style.position = cell.style.position || 'relative';
      let tip = cell.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) { tip = document.createElement('div'); tip.className = 'd3-tooltip'; Object.assign(tip.style, { position:'absolute', top:'0', left:'0', transform:'translate(-9999px,-9999px)', pointerEvents:'none', padding:'8px 10px', borderRadius:'8px', fontSize:'12px', lineHeight:'1.35', border:'1px solid var(--border-color)', background:'var(--surface-bg)', color:'var(--text-color)', boxShadow:'0 4px 24px rgba(0,0,0,.18)', opacity:'0', transition:'opacity .12s ease' }); tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign='left'; tip.appendChild(tipInner); cell.appendChild(tip);} else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // State
      let metricList = []; let runList = []; let runOrder = []; const dataByMetric = new Map();
      let width = 800, height = 340; const margin = { top: 12, right: 20, bottom: 46, left: 56 };
      const xScale = d3.scaleLinear(); const yScale = d3.scaleLinear();
      const lineGen = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value));
      let isRankStrictFlag = false; let rankTickMax = 1;
      
      // Colors and markers (match original embeds)
      const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
      const pool = [primary, '#4EA5B7', '#E38A42', '#CEC0FA', ...(d3.schemeTableau10||[])];
      const markerShapes = ['circle', 'square', 'triangle', 'diamond', 'inverted-triangle'];
      const markerSize = 6;
      function drawMarker(selection, shape, size) {
        const s = size / 2;
        switch (shape) {
          case 'circle':
            return selection.append('circle').attr('r', s);
          case 'square':
            return selection.append('rect').attr('x', -s).attr('y', -s).attr('width', size).attr('height', size);
          case 'triangle':
            return selection.append('path').attr('d', `M0,${-s * 1.2} L${s * 1.1},${s * 0.6} L${-s * 1.1},${s * 0.6} Z`);
          case 'diamond':
            return selection.append('path').attr('d', `M0,${-s * 1.2} L${s * 1.1},0 L0,${s * 1.2} L${-s * 1.1},0 Z`);
          case 'inverted-triangle':
            return selection.append('path').attr('d', `M0,${s * 1.2} L${s * 1.1},${-s * 0.6} L${-s * 1.1},${-s * 0.6} Z`);
          default:
            return selection.append('circle').attr('r', s);
        }
      }
      // Ready signal for async load completion
      let readyResolve = null;
      const ready = new Promise((res)=> { readyResolve = res; });

      function updateScales(){
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const axisColor = isDark ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.25)';
        const tickColor = isDark ? 'rgba(255,255,255,0.70)' : 'rgba(0,0,0,0.55)';
        const gridColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)';

        const rect = cell.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (cell.clientWidth || 800)));
        height = Math.max(280, Math.round(width / 2.3));
        svg.attr('width', width).attr('height', height).attr('viewBox', `0 0 ${width} ${height}`).attr('preserveAspectRatio','xMidYMid meet');
        const innerWidth = width - margin.left - margin.right; const innerHeight = height - margin.top - margin.bottom;
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        xScale.range([0, innerWidth]); yScale.range([innerHeight, 0]);

        // Y ticks
        let yTicks = [];
        if (isRankStrictFlag) { const maxR = Math.max(1, Math.round(rankTickMax)); for (let v=1; v<=maxR; v+=1) yTicks.push(v); }
        else { yTicks = yScale.ticks(6); }

        // Grid
        gGrid.selectAll('*').remove();
        gGrid.selectAll('line').data(yTicks).join('line')
          .attr('x1',0).attr('x2',innerWidth).attr('y1',d=>yScale(d)).attr('y2',d=>yScale(d))
          .attr('stroke',gridColor).attr('stroke-width',1).attr('shape-rendering','crispEdges');

        // Axes
        gAxes.selectAll('*').remove();
        let xAxis = d3.axisBottom(xScale).tickSizeOuter(0); xAxis = xAxis.ticks(8);
        const isMobile = (typeof window !== 'undefined' && window.matchMedia) ? window.matchMedia('(max-width: 980px)').matches : false;
        if (isMobile) {
          const fmtK = (v) => {
            const abs = Math.abs(v);
            if (abs >= 1000) {
              const n = v / 1000;
              return (Math.round(n) === n ? n : d3.format('.1f')(n)) + 'K';
            }
            return d3.format('d')(v);
          };
          xAxis = xAxis.tickFormat(fmtK);
        }
        const yAxis = d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(isRankStrictFlag ? d3.format('d') : d3.format('.2f'));
        gAxes.append('g').attr('transform', `translate(0,${innerHeight})`).call(xAxis).call(g=>{ g.selectAll('path, line').attr('stroke',axisColor); g.selectAll('text').attr('fill',tickColor).style('font-size','11px'); });
        gAxes.append('g').call(yAxis).call(g=>{ g.selectAll('path, line').attr('stroke',axisColor); g.selectAll('text').attr('fill',tickColor).style('font-size','11px'); });

        // Legend box (top-right)
        // Per-cell legend hidden; global legend is used
        const legendWidth = 0, legendHeight = 0;
        gLegend.attr('x', 0).attr('y', 0).attr('width', legendWidth).attr('height', legendHeight);
        const legendRoot = gLegend.selectAll('div').data([0]).join('xhtml:div');
        Object.assign(legendRoot.node().style, { width:'0px', height:'0px', display:'none' });
        return { innerWidth, innerHeight, tickColor };
      }

      function renderMetric(metricKey){
        const map = dataByMetric.get(metricKey) || {};
        const runs = runOrder;
        let minStep = Infinity, maxStep = -Infinity, maxVal = 0, minVal = Infinity;
        const isRank = /rank/i.test(metricKey); const isAverage = /average/i.test(metricKey); const isRankStrict = isRank && !isAverage;
        runs.forEach(r => { (map[r]||[]).forEach(pt => { const v = isRankStrict ? Math.round(pt.value) : pt.value; minStep=Math.min(minStep,pt.step); maxStep=Math.max(maxStep,pt.step); maxVal=Math.max(maxVal,v); minVal=Math.min(minVal,v); }); });
        if (!isFinite(minStep) || !isFinite(maxStep)) return;
        xScale.domain([minStep, maxStep]); if (isRank) { rankTickMax = Math.max(1, Math.round(maxVal)); yScale.domain([rankTickMax, 1]); } else { yScale.domain([minVal, maxVal]).nice(); }
        isRankStrictFlag = isRankStrict;

        const { innerWidth, innerHeight } = updateScales();

        const series = runs.map((r, i) => ({ run:r, color: pool[i % pool.length], marker: markerShapes[i % markerShapes.length], values:(map[r]||[]).slice().sort((a,b)=>a.step-b.step).map(pt => isRankStrict ? { step: pt.step, value: Math.round(pt.value), stderr: pt.stderr } : pt) }));

        // zones ± stderr (métriques non rank)
        gAreas.selectAll('*').remove();
        if (!isRank) {
          series.forEach((s) => {
            const withErr = s.values.filter(v => v && v.stderr != null && isFinite(v.stderr) && v.stderr > 0 && isFinite(v.value));
            if (!withErr.length) return;
            const upper = withErr.map(d => [xScale(d.step), yScale(d.value + d.stderr)]);
            const lower = withErr.slice().reverse().map(d => [xScale(d.step), yScale(d.value - d.stderr)]);
            const coords = upper.concat(lower);
            const pathData = d3.line().x(d=>d[0]).y(d=>d[1]).curve(d3.curveLinearClosed)(coords);
            gAreas.append('path').attr('d', pathData).attr('fill', s.color).attr('opacity', 0.15).attr('stroke', 'none');
          });
        }

        const paths = gLines.selectAll('path.run-line').data(series, d=>d.run);
        paths.enter().append('path').attr('class','run-line').attr('fill','none').attr('stroke-width',2).attr('opacity',0.9)
          .attr('stroke', d=>d.color).attr('d', d=>lineGen(d.values))
          .merge(paths).attr('stroke', d=>d.color).attr('d', d=>lineGen(d.values));
        paths.exit().remove();

        gPoints.selectAll('*').remove();
        series.forEach((s, idx) => {
          const pointGroup = gPoints.selectAll(`.points-${idx}`)
            .data(s.values)
            .join('g')
            .attr('class', `points-${idx}`)
            .attr('transform', d => `translate(${xScale(d.step)},${yScale(d.value)})`);
          drawMarker(pointGroup, s.marker, markerSize)
            .attr('fill', s.color)
            .attr('stroke', s.color)
            .attr('stroke-width', 1.5)
            .style('cursor', 'crosshair');
        });

        // No per-cell legend content (handled globally)

        // Hover
        gHover.selectAll('*').remove();
        const overlay = gHover.append('rect').attr('fill','transparent').style('cursor','crosshair').attr('x',0).attr('y',0).attr('width', innerWidth).attr('height', innerHeight);
        const hoverLine = gHover.append('line').attr('stroke','rgba(0,0,0,0.25)').attr('stroke-width',1).attr('y1',0).attr('y2',innerHeight).style('display','none');
        const stepSet = new Set(); series.forEach(s=>s.values.forEach(v=>stepSet.add(v.step))); const steps = Array.from(stepSet).sort((a,b)=>a-b);
        function onMove(ev){ const [mx,my]=d3.pointer(ev, overlay.node()); const nearest = steps.reduce((best,s)=> Math.abs(s - xScale.invert(mx)) < Math.abs(best - xScale.invert(mx)) ? s : best, steps[0]); const xpx = xScale(nearest); hoverLine.attr('x1',xpx).attr('x2',xpx).style('display',null);
          let html = `<div><strong>${titleText}</strong></div><div><strong>step</strong> ${nearest}</div>`; series.forEach(s=>{ const m = new Map(s.values.map(v=>[v.step, v])); const pt = m.get(nearest); if (pt && pt.value!=null){ const fmt = (vv)=> (isRankStrictFlag? d3.format('d')(vv) : (+vv).toFixed(4)); const err = (pt.stderr!=null && isFinite(pt.stderr) && pt.stderr>0) ? ` ± ${fmt(pt.stderr)}` : ''; html+=`<div><span style=\"display:inline-block;width:10px;height:10px;background:${s.color};border-radius:50%;margin-right:6px;\"></span><strong>${s.run}</strong> ${fmt(pt.value)}${err}</div>`; }});
          tipInner.innerHTML = html; const offsetX=12, offsetY=12; tip.style.opacity='1'; tip.style.transform=`translate(${Math.round(mx+offsetX+margin.left)}px, ${Math.round(my+offsetY+margin.top)}px)`; }
        function onLeave(){ tip.style.opacity='0'; tip.style.transform='translate(-9999px, -9999px)'; hoverLine.style('display','none'); }
        overlay.on('mousemove', onMove).on('mouseleave', onLeave);
      }

      async function load(){
        try {
          const file = (csvPath || '').split('/').pop();
          const CANDIDATES = [
            csvPath,
            `/data/${file}`,
            `./assets/data/${file}`,
            `../assets/data/${file}`,
            `../../assets/data/${file}`
          ].filter(Boolean);
          let text = null;
          for (const p of CANDIDATES){
            try { const r = await fetch(p, { cache:'no-cache' }); if (r.ok) { text = await r.text(); break; } } catch(e){}
          }
          if (text == null) throw new Error(`CSV not found: ${file}`);
          const rows = d3.csvParse(text, d => ({ run:(d.run||'').trim(), step:+d.step, metric:(d.metric||'').trim(), value:+d.value, stderr: (d.stderr!=null && d.stderr!=='') ? +d.stderr : null }));
          metricList = Array.from(new Set(rows.map(r=>r.metric))).sort();
          runList = Array.from(new Set(rows.map(r=>r.run))).sort(); runOrder = runList;
          metricList.forEach(m => { const map={}; runList.forEach(r=>map[r]=[]); rows.filter(r=>r.metric===m).forEach(r=>{ if(!isNaN(r.step)&&!isNaN(r.value)) map[r.run].push({ step:r.step, value:r.value, stderr:r.stderr }); }); dataByMetric.set(m, map); });
          const preferred = metricList.find(m => m === 'ai2d_exact_match') || metricList.find(m => /average_rank/i.test(m));
          const def = preferred || metricList[0];
          renderMetric(def);
          const ro = window.ResizeObserver ? new ResizeObserver(()=>renderMetric(def)) : null; if (ro) ro.observe(cell);
          if (typeof readyResolve === 'function') readyResolve();
        } catch (e) {
          const pre = document.createElement('pre'); pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)'; pre.style.fontSize = '12px'; pre.style.whiteSpace = 'pre-wrap'; cell.appendChild(pre);
          if (typeof readyResolve === 'function') readyResolve();
        }
      }
      load();
      
      return {
        ready,
        getMetrics: () => metricList.slice(),
        setMetric: (m) => { if (m) renderMetric(m); }
      };
    }

    const bootstrap = () => {
      const scriptEl = THIS_SCRIPT;
      let host = null;
      // Try finding within parent (fragment mount is inside parent)
      if (scriptEl && scriptEl.parentElement && scriptEl.parentElement.querySelector) {
        host = scriptEl.parentElement.querySelector('.filters-quad');
      }
      // Fallback: scan previous siblings
      if (!host) {
        let sib = scriptEl && scriptEl.previousElementSibling;
        while (sib && !(sib.classList && sib.classList.contains('filters-quad'))) {
          sib = sib.previousElementSibling;
        }
        host = sib || null;
      }
      // Last resort: global query
      if (!host) { host = document.querySelector('.filters-quad'); }
      if (!host) return;
      if (host.dataset && host.dataset.mounted === 'true') return; if (host.dataset) host.dataset.mounted = 'true';
      const cells = host.querySelectorAll('.quad-cell'); if (!cells.length) return;
      const instances = Array.from(cells).map(cell => initRunLine(cell));

      (async () => {
        // Wait for all charts to finish loading their CSVs
        await Promise.all(instances.map(i => i.ready));
        const lists = instances.map(i => i.getMetrics()).filter(a => Array.isArray(a) && a.length);
        const intersect = (arrs) => arrs.reduce((acc, cur) => acc.filter(x => cur.includes(x)));
        let metrics = lists.length ? intersect(lists) : [];
        if (!metrics.length) { metrics = lists[0] || []; }
        const def = (metrics.includes('ai2d_exact_match') ? 'ai2d_exact_match' : (metrics.find(m => /average_rank/i.test(m)) || metrics[0] || ''));

        let ctrl = host.querySelector('.filters-quad__controls');
        if (!ctrl) { ctrl = document.createElement('div'); ctrl.className = 'filters-quad__controls'; host.insertBefore(ctrl, host.firstChild); }
        ctrl.innerHTML = '';
        const label = document.createElement('label'); label.textContent = 'Metric';
        const select = document.createElement('select');
        metrics.forEach(m => { const o=document.createElement('option'); o.value=m; o.textContent=m; select.appendChild(o); });
        if (def) select.value = def;
        label.appendChild(select); ctrl.appendChild(label);

        const applyAll = (v) => instances.forEach(i => i && typeof i.setMetric === 'function' && i.setMetric(v));
        if (def) applyAll(def);
        select.addEventListener('change', () => applyAll(select.value));

        // Légende globale (couleurs + formes, alignée avec les marqueurs des séries)
        const legendHost = host.querySelector('.filters-quad__legend');
        if (legendHost) {
          try {
            const f = '/data/formatting_filters.csv';
            const r = await fetch(f, { cache:'no-cache' });
            if (r.ok && window.d3 && window.d3.csvParse) {
              const txt = await r.text();
              const rows = window.d3.csvParse(txt);
              const runList = Array.from(new Set(rows.map(row => String(row.run||'').trim()).filter(Boolean)));
              const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
              const pool = [primary, '#4EA5B7', '#E38A42', '#CEC0FA', ...((window.d3 && window.d3.schemeTableau10) ? window.d3.schemeTableau10 : ['#4e79a7','#f28e2b','#e15759','#76b7b2','#59a14f','#edc948','#b07aa1','#ff9da7','#9c755f','#bab0ab'])];
              const markerShapes = ['circle', 'square', 'triangle', 'diamond', 'inverted-triangle'];
              const shapeSVG = (shape, color) => {
                const size = 12; const s = size/2; const stroke = color;
                if (shape === 'circle') return `<svg width="12" height="12" viewBox="-6 -6 12 12" aria-hidden="true"><circle r="5" fill="${color}" stroke="${stroke}" stroke-width="1" /></svg>`;
                if (shape === 'square') return `<svg width="12" height="12" viewBox="-6 -6 12 12" aria-hidden="true"><rect x="-5" y="-5" width="10" height="10" fill="${color}" stroke="${stroke}" stroke-width="1" /></svg>`;
                if (shape === 'triangle') return `<svg width="12" height="12" viewBox="-6 -6 12 12" aria-hidden="true"><path d="M0,-6 L5,3 L-5,3 Z" fill="${color}" stroke="${stroke}" stroke-width="1" /></svg>`;
                if (shape === 'diamond') return `<svg width="12" height="12" viewBox="-6 -6 12 12" aria-hidden="true"><path d="M0,-6 L6,0 L0,6 L-6,0 Z" fill="${color}" stroke="${stroke}" stroke-width="1" /></svg>`;
                if (shape === 'inverted-triangle') return `<svg width="12" height="12" viewBox="-6 -6 12 12" aria-hidden="true"><path d="M0,6 L5,-3 L-5,-3 Z" fill="${color}" stroke="${stroke}" stroke-width="1" /></svg>`;
                return `<svg width="12" height="12" viewBox="-6 -6 12 12" aria-hidden="true"><circle r="5" fill="${color}" stroke="${stroke}" stroke-width="1" /></svg>`;
              };
              legendHost.innerHTML = runList.map((name, i)=> {
                const color = pool[i % pool.length];
                const shape = markerShapes[i % markerShapes.length];
                return `<span class="item">${shapeSVG(shape, color)}<span>${name}</span></span>`;
              }).join('');
            }
          } catch {}
        }
      })();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script>

