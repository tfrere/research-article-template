<div class="d3-sft-packing-vs-no-packing"></div>
<style>
  .d3-sft-packing-vs-no-packing {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .d3-sft-packing-vs-no-packing svg {
    display: block;
    overflow: visible;
  }

  .d3-sft-packing-vs-no-packing .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-packing-vs-no-packing .bar:hover {
    opacity: 0.8;
  }

  .d3-sft-packing-vs-no-packing .axes path,
  .d3-sft-packing-vs-no-packing .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-no-packing .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-packing-vs-no-packing .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 500;
  }

  .d3-sft-packing-vs-no-packing .grid line {
    stroke: var(--grid-color);
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-no-packing .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-no-packing .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-no-packing .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-no-packing .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-packing-vs-no-packing .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-no-packing .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-packing-vs-no-packing .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-no-packing .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-no-packing .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-no-packing .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 6px center;
    background-size: 16px;
  }

  .d3-sft-packing-vs-no-packing .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }

  .d3-sft-packing-vs-no-packing .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-sft-packing-vs-no-packing .d3-tooltip__inner {
    text-align: left;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-packing-vs-no-packing'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-packing-vs-no-packing'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // Data loading
      const CSV_PATHS = [
        '/data/sft_packing-vs-no-packing.csv',
        './assets/data/sft_packing-vs-no-packing.csv',
        '../assets/data/sft_packing-vs-no-packing.csv',
        '../../assets/data/sft_packing-vs-no-packing.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found in any of the expected locations');
      };

      fetchFirstAvailable(CSV_PATHS)
        .then((csvText) => {
          const rawData = d3.csvParse(csvText);

          // Process data
          const benchmarks = Object.keys(rawData[0]).filter(k => k !== 'Packing' && k !== 'Reasoning mode');
          const reasoningModes = [...new Set(rawData.map(d => d['Reasoning mode']))];

          let currentMode = reasoningModes[1];

          // Get colors from ColorPalettes
          let colors;
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            colors = window.ColorPalettes.getColors('categorical', 2);
          } else {
            // Fallback to simple colors
            colors = ['#4e79a7', '#f28e2c'];
          }

          const colorMap = {
            'TRUE': colors[0],
            'FALSE': colors[1]
          };

          // SVG setup
          const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
          const gRoot = svg.append('g');
          const gBars = gRoot.append('g').attr('class', 'bars');
          const gAxes = gRoot.append('g').attr('class', 'axes');
          const gGrid = gRoot.append('g').attr('class', 'grid');

          let width = 800;
          let height = 400;
          const margin = { top: 16, right: 28, bottom: 56, left: 64 };

          const xBenchmark = d3.scaleBand().padding(0.2);
          const xPacking = d3.scaleBand().padding(0.05);
          const yScale = d3.scaleLinear();

          function updateSize() {
            width = container.clientWidth || 800;
            height = Math.max(320, Math.round(width / 2.2));
            svg.attr('width', width).attr('height', height);
            gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
            return {
              innerWidth: width - margin.left - margin.right,
              innerHeight: height - margin.top - margin.bottom
            };
          }

          function render() {
            const { innerWidth, innerHeight } = updateSize();

            // Filter data for current reasoning mode
            const filteredData = rawData.filter(d => d['Reasoning mode'] === currentMode);

            // Prepare data structure for grouped bars
            const chartData = benchmarks.map(benchmark => {
              return {
                benchmark,
                values: filteredData.map(d => ({
                  packing: d.Packing,
                  value: +d[benchmark]
                }))
              };
            });

            // Update scales
            xBenchmark.domain(benchmarks).range([0, innerWidth]);
            xPacking.domain(['TRUE', 'FALSE']).range([0, xBenchmark.bandwidth()]);

            const maxValue = d3.max(chartData, d => d3.max(d.values, v => v.value)) || 100;
            yScale.domain([0, maxValue]).range([innerHeight, 0]).nice();

            // Grid
            gGrid.selectAll('.grid-line').data(yScale.ticks(5))
              .join('line')
              .attr('class', 'grid-line')
              .attr('x1', 0)
              .attr('x2', innerWidth)
              .attr('y1', d => yScale(d))
              .attr('y2', d => yScale(d))
              .attr('stroke', 'var(--grid-color)');

            // Draw bars
            const groups = gBars.selectAll('.benchmark-group')
              .data(chartData, d => d.benchmark);

            const groupsEnter = groups.enter()
              .append('g')
              .attr('class', 'benchmark-group');

            groups.exit().remove();

            const groupsMerged = groupsEnter.merge(groups)
              .attr('transform', d => `translate(${xBenchmark(d.benchmark)},0)`);

            // Bars within each group
            groupsMerged.each(function (groupData) {
              const bars = d3.select(this)
                .selectAll('.bar')
                .data(groupData.values, d => d.packing);

              bars.join('rect')
                .attr('class', 'bar')
                .attr('x', d => xPacking(d.packing))
                .attr('width', xPacking.bandwidth())
                .attr('fill', d => colorMap[d.packing])
                .on('mouseenter', function (event, d) {
                  const packingLabel = d.packing === 'TRUE' ? 'Packing' : 'No Packing';
                  tipInner.innerHTML = `<strong>${groupData.benchmark}</strong><br/>${packingLabel}: ${d.value.toFixed(2)}`;
                  tip.style.opacity = '1';
                  const [mx, my] = d3.pointer(event, container);
                  tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
                })
                .on('mouseleave', function () {
                  tip.style.opacity = '0';
                  tip.style.transform = 'translate(-9999px, -9999px)';
                })
                .transition()
                .duration(150)
                .attr('y', d => yScale(d.value))
                .attr('height', d => Math.max(0, innerHeight - yScale(d.value)));
            });

            // Axes
            const xAxis = d3.axisBottom(xBenchmark);
            const yAxis = d3.axisLeft(yScale).ticks(5);

            gAxes.selectAll('.x-axis').data([0])
              .join('g')
              .attr('class', 'x-axis')
              .attr('transform', `translate(0,${innerHeight})`)
              .call(xAxis)
              .selectAll('text')
              .style('text-anchor', 'middle');

            gAxes.selectAll('.y-axis').data([0])
              .join('g')
              .attr('class', 'y-axis')
              .call(yAxis);

            // Axis labels
            gAxes.selectAll('.y-label').data([0])
              .join('text')
              .attr('class', 'y-label axis-label')
              .attr('transform', 'rotate(-90)')
              .attr('x', -innerHeight / 2)
              .attr('y', -48)
              .attr('text-anchor', 'middle')
              .text('Score (%)');
          }

          // Create header with legend and controls
          function makeHeader() {
            let header = container.querySelector('.header');
            if (!header) {
              header = document.createElement('div');
              header.className = 'header';
              container.appendChild(header);
            }

            // Create legend
            let legend = header.querySelector('.legend');
            if (!legend) {
              legend = document.createElement('div');
              legend.className = 'legend';
              header.appendChild(legend);
            }

            let title = legend.querySelector('.legend-title');
            if (!title) {
              title = document.createElement('div');
              title.className = 'legend-title';
              title.textContent = 'Legend';
              legend.appendChild(title);
            }

            let items = legend.querySelector('.items');
            if (!items) {
              items = document.createElement('div');
              items.className = 'items';
              legend.appendChild(items);
            }

            items.innerHTML = '';
            const legendData = [
              { label: 'Packing', packing: 'TRUE' },
              { label: 'No Packing', packing: 'FALSE' }
            ];

            legendData.forEach(({ label, packing }) => {
              const el = document.createElement('span');
              el.className = 'item';
              const sw = document.createElement('span');
              sw.className = 'swatch';
              sw.style.background = colorMap[packing];
              const txt = document.createElement('span');
              txt.textContent = label;
              el.appendChild(sw);
              el.appendChild(txt);
              items.appendChild(el);
            });

            // Create controls
            let controls = header.querySelector('.controls');
            if (!controls) {
              controls = document.createElement('div');
              controls.className = 'controls';
              header.appendChild(controls);
            }

            let controlGroup = controls.querySelector('.control-group');
            if (!controlGroup) {
              controlGroup = document.createElement('div');
              controlGroup.className = 'control-group';
              controls.appendChild(controlGroup);
            }

            let label = controlGroup.querySelector('label');
            if (!label) {
              label = document.createElement('label');
              label.setAttribute('for', 'reasoning-mode-select');
              label.textContent = 'Reasoning mode';
              controlGroup.appendChild(label);
            }

            let select = controlGroup.querySelector('select');
            if (!select) {
              select = document.createElement('select');
              select.id = 'reasoning-mode-select';
              controlGroup.appendChild(select);
            }

            select.innerHTML = '';
            reasoningModes.forEach(mode => {
              const option = document.createElement('option');
              option.value = mode;
              option.textContent = mode;
              option.selected = mode === currentMode;
              select.appendChild(option);
            });

            select.addEventListener('change', (e) => {
              currentMode = e.target.value;
              render();
            });
          }

          // Initial setup
          makeHeader();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch((err) => {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>