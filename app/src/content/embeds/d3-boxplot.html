<div class="d3-boxplot" style="width:100%;margin:10px 0;"></div>
<style>
  .d3-boxplot .controls {
    margin-top: 12px;
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
  }
  .d3-boxplot .controls label {
    font-size: 12px;
    color: var(--muted-color);
    display: flex;
    align-items: center;
    gap: 8px;
    white-space: nowrap;
    padding: 6px 10px;
  }
  .d3-boxplot .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--surface-bg);
    color: var(--text-color);
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%230f1115' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    background-size: 12px;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    cursor: pointer;
    transition: border-color .15s ease, box-shadow .15s ease;
  }
  [data-theme="dark"] .d3-boxplot .controls select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
  }
  .d3-boxplot .controls select:hover { border-color: var(--primary-color); }
  .d3-boxplot .controls select:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(232,137,171,.25); outline: none; }
  .d3-boxplot .legend { font-size: 12px; line-height: 1.35; color: var(--text-color); }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-boxplot'))){
        const cs = Array.from(document.querySelectorAll('.d3-boxplot')).filter(el => !(el.dataset && el.dataset.mounted==='true'));
        container = cs[cs.length-1] || null;
      }
      if (!container) return;
      if (container.dataset){ if (container.dataset.mounted==='true') return; container.dataset.mounted='true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) { tip = document.createElement('div'); tip.className = 'd3-tooltip'; Object.assign(tip.style,{ position:'absolute', top:'0px', left:'0px', transform:'translate(-9999px, -9999px)', pointerEvents:'none', padding:'8px 10px', borderRadius:'8px', fontSize:'12px', lineHeight:'1.35', border:'1px solid var(--border-color)', background:'var(--surface-bg)', color:'var(--text-color)', boxShadow:'0 4px 24px rgba(0,0,0,.18)', opacity:'0', transition:'opacity .12s ease' }); tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign='left'; tip.appendChild(tipInner); container.appendChild(tip); } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Controls
      const controls = document.createElement('div'); controls.className='controls';
      const labelMetric = document.createElement('label'); labelMetric.textContent='Metric';
      const selMetric = document.createElement('select');
      labelMetric.appendChild(selMetric);

      // SVG
      const svg = d3.select(container).append('svg').attr('width','100%').style('display','block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class','grid');
      const gAxes = gRoot.append('g').attr('class','axes');
      const gBoxes = gRoot.append('g').attr('class','boxes');

      // State & scales
      let width=800,height=360; const margin={top:16,right:28,bottom:56,left:64};
      const x=d3.scaleBand().padding(0.4);
      const y=d3.scaleLinear();
      const color=d3.scaleOrdinal().range(['var(--primary-color)','rgb(78, 165, 183)','rgb(227, 138, 66)','rgb(206, 192, 250)']);

      // Data (real): distribution of a chosen metric across runs
      let allRows = [];
      let groups = [];
      let currentMetric = null;
      let stats = [];

      async function fetchFirstAvailable(paths){
        for (const p of paths){
          try { const res = await fetch(p, { cache:'no-cache' }); if (res.ok) return await res.text(); } catch(e){}
        }
        throw new Error('Failed to load boxplot data');
      }

      function computeStatsForMetric(metric){
        const byRun = d3.rollup(allRows.filter(r=>r.metric===metric), v=> v.map(r=>+r.value).filter(Number.isFinite), r=>r.run);
        groups = Array.from(byRun.keys());
        const result = groups.map((g)=>{
          const data = (byRun.get(g) || []).slice().sort((a,b)=>a-b);
          if (!data.length) return { key:g, q1:NaN, med:NaN, q3:NaN, min:NaN, max:NaN, outliers:[] };
          const q1 = d3.quantile(data, 0.25);
          const med = d3.quantile(data, 0.5);
          const q3 = d3.quantile(data, 0.75);
          const iqr = q3 - q1;
          const lo = q1 - 1.5*iqr;
          const hi = q3 + 1.5*iqr;
          const min = d3.min(data.filter(v=>v>=lo));
          const max = d3.max(data.filter(v=>v<=hi));
          const outliers = data.filter(v=>v<lo || v>hi);
          return { key:g, q1, med, q3, iqr, min, max, outliers };
        });
        return result;
      }

      function updateScales(){
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const axisColor = isDark ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.25)';
        const tickColor = isDark ? 'rgba(255,255,255,0.70)' : 'rgba(0,0,0,0.55)';
        const gridColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)';

        width = container.clientWidth || 800; height = Math.max(260, Math.round(width/3)); svg.attr('width', width).attr('height', height);
        const innerWidth = width - margin.left - margin.right; const innerHeight = height - margin.top - margin.bottom; gRoot.attr('transform', `translate(${margin.left},${margin.top})`);

        x.domain(groups).range([0, innerWidth]);
        const yMin = Math.floor(d3.min(stats, d=>d.min ?? 0))-0; const yMax = Math.ceil(d3.max(stats, d=>d.max ?? 1))+0;
        y.domain([yMin, yMax]).range([innerHeight,0]).nice();

        // Grid
        gGrid.selectAll('*').remove();
        gGrid.selectAll('line.grid-y').data(y.ticks(6)).join('line')
          .attr('class','grid-y').attr('x1',0).attr('x2',innerWidth).attr('y1',d=>y(d)).attr('y2',d=>y(d))
          .attr('stroke', gridColor).attr('stroke-width',1).attr('shape-rendering','crispEdges');

        // Axes
        gAxes.selectAll('*').remove();
        gAxes.append('g').attr('transform', `translate(0,${innerHeight})`).call(d3.axisBottom(x)).call((g)=>{ g.selectAll('path, line').attr('stroke', axisColor); g.selectAll('text').attr('fill', tickColor).style('font-size','12px'); });
        gAxes.append('g').call(d3.axisLeft(y).ticks(6)).call((g)=>{ g.selectAll('path, line').attr('stroke', axisColor); g.selectAll('text').attr('fill', tickColor).style('font-size','12px'); });
        gAxes.append('text').attr('class','axis-label axis-label--x').attr('x', innerWidth/2).attr('y', innerHeight + 44).attr('text-anchor','middle').style('font-size','12px').style('fill', tickColor).text('Group');
        gAxes.append('text').attr('class','axis-label axis-label--y').attr('text-anchor','middle').attr('transform', `translate(${-48},${innerHeight/2}) rotate(-90)`).style('font-size','12px').style('fill', tickColor).text('Value');

        return { innerWidth, innerHeight };
      }

      function draw(){
        const { innerWidth, innerHeight } = updateScales();
        const bw = Math.max(10, x.bandwidth());

        // Boxes
        const groupsSel = gBoxes.selectAll('g.bp').data(stats, d=>d.key);
        const gEnter = groupsSel.enter().append('g').attr('class','bp').attr('transform', d=>`translate(${x(d.key)},0)`);
        const merged = gEnter.merge(groupsSel).attr('transform', d=>`translate(${x(d.key)},0)`);
        groupsSel.exit().remove();

        // Box rect (Q1-Q3)
        const box = merged.selectAll('rect.box').data(d=>[d]);
        box.enter().append('rect').attr('class','box')
          .attr('x', 0).attr('width', bw)
          .attr('y', d=>y(d.q3)).attr('height', d=>Math.max(0.5, y(d.q1) - y(d.q3)))
          .attr('fill','var(--surface-bg)')
          .attr('stroke', 'var(--primary-color)')
          .attr('rx', 4).attr('ry', 4)
          .merge(box)
          .transition().duration(180)
          .attr('y', d=>y(d.q3)).attr('height', d=>Math.max(0.5, y(d.q1) - y(d.q3)));
        box.exit().remove();

        // Median line
        const med = merged.selectAll('line.med').data(d=>[d]);
        med.enter().append('line').attr('class','med')
          .attr('x1', 0).attr('x2', bw)
          .attr('y1', d=>y(d.med)).attr('y2', d=>y(d.med))
          .attr('stroke','var(--primary-color)').attr('stroke-width',2)
          .merge(med)
          .transition().duration(180)
          .attr('y1', d=>y(d.med)).attr('y2', d=>y(d.med));
        med.exit().remove();

        // Whiskers
        const whisker = merged.selectAll('line.whisk').data(d=>[d]);
        whisker.enter().append('line').attr('class','whisk')
          .attr('x1', bw/2).attr('x2', bw/2)
          .attr('y1', d=>y(d.min)).attr('y2', d=>y(d.max))
          .attr('stroke','var(--border-color)')
          .merge(whisker)
          .transition().duration(180)
          .attr('y1', d=>y(d.min)).attr('y2', d=>y(d.max));
        whisker.exit().remove();

        // Whisker caps
        const caps = merged.selectAll('g.caps').data(d=>[d]);
        const capsEnter = caps.enter().append('g').attr('class','caps');
        capsEnter.append('line').attr('class','cap cap--min').attr('x1',0).attr('x2',bw).attr('y1',d=>y(d.min)).attr('y2',d=>y(d.min)).attr('stroke','var(--border-color)');
        capsEnter.append('line').attr('class','cap cap--max').attr('x1',0).attr('x2',bw).attr('y1',d=>y(d.max)).attr('y2',d=>y(d.max)).attr('stroke','var(--border-color)');
        caps.merge(capsEnter).select('.cap--min').transition().duration(180).attr('y1',d=>y(d.min)).attr('y2',d=>y(d.min));
        caps.merge(capsEnter).select('.cap--max').transition().duration(180).attr('y1',d=>y(d.max)).attr('y2',d=>y(d.max));
        caps.exit().remove();

        // Outliers
        const outs = merged.selectAll('circle.out').data(d=>d.outliers.map(v=>({key:d.key, v})));
        outs.enter().append('circle').attr('class','out')
          .attr('cx', bw/2).attr('cy', d=>y(d.v)).attr('r', 2.5)
          .attr('fill', 'var(--primary-color)')
          .on('mouseenter', function(ev, d){ tipInner.innerHTML = `<div><strong>${d.key}</strong> outlier: ${d.v.toFixed(2)}</div>`; tip.style.opacity='1'; d3.select(this).attr('r',3.2); })
          .on('mousemove', function(ev){ const [mx,my]=d3.pointer(ev, container); const ox=12, oy=12; tip.style.transform = `translate(${Math.round(mx+ox)}px, ${Math.round(my+oy)}px)`; })
          .on('mouseleave', function(){ tip.style.opacity='0'; tip.style.transform='translate(-9999px, -9999px)'; d3.select(this).attr('r',2.5); })
          .merge(outs)
          .transition().duration(180)
          .attr('cy', d=>y(d.v));
        outs.exit().remove();
      }

      container.appendChild(controls);
      controls.appendChild(labelMetric);

      (async () => {
        try {
          const csvText = await fetchFirstAvailable([
            '/data/all_ratings_luis.csv',
            '/data/against_baselines.csv',
            '/data/ss_vs_s1.csv',
            './assets/data/all_ratings_luis.csv',
            '../assets/data/all_ratings_luis.csv'
          ]);
          allRows = d3.csvParse(csvText, d=>({ run: d.run, step: +d.step, metric: d.metric, value: +d.value }));
          const metrics = Array.from(new Set(allRows.map(r=>r.metric))).filter(Boolean).slice(0, 20);
          metrics.forEach(m=>{ const o=document.createElement('option'); o.value=m; o.textContent=m; selMetric.appendChild(o); });
          currentMetric = metrics.includes('textvqa_val_exact_match') ? 'textvqa_val_exact_match' : metrics[0];
          selMetric.value = currentMetric;
          selMetric.addEventListener('change', (e)=>{ currentMetric = e.target.value; stats = computeStatsForMetric(currentMetric); draw(); });
          stats = computeStatsForMetric(currentMetric);
          draw();
        } catch (e) {
          const pre = document.createElement('pre'); pre.style.color = 'crimson'; pre.textContent = 'Failed to load boxplot data.'; container.appendChild(pre);
        }
      })();

      const rerender = () => { draw(); };
      if (window.ResizeObserver) { const ro = new ResizeObserver(()=>rerender()); ro.observe(container); } else { window.addEventListener('resize', rerender); }
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script>


