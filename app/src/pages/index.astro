---
import Article, { frontmatter as articleFM } from './article.mdx';
import Meta from '../components/Meta.astro';
import HtmlFragment from '../components/HtmlFragment.astro';
import Footer from '../components/Footer.astro';
import ThemeToggle from '../components/ThemeToggle.astro';
import SeoHead from '../components/SeoHead.astro';
import ogDefault from '../assets/images/visual-vocabulary-poster.png';
import '../styles/global.scss';
const docTitle = articleFM?.title ?? 'Untitled article';
// Autoriser un retour Ã  la ligne dans le titre via "\n" ou sauts de ligne YAML
const docTitleHtml = (articleFM?.title ?? 'Untitled article')
  .replace(/\\n/g, '<br/>')
  .replace(/\n/g, '<br/>');
const description = articleFM?.description ?? '';
const authors = articleFM?.authors ?? [];
const published = articleFM?.published ?? undefined;
const tags = articleFM?.tags ?? [];
// Prefer ogImage from frontmatter if provided
const fmOg = articleFM?.ogImage as string | undefined;
const imageAbs = fmOg && fmOg.startsWith('http')
  ? fmOg
  : (Astro.site ? new URL((fmOg ?? ogDefault.src), Astro.site).toString() : (fmOg ?? ogDefault.src));
---
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{docTitle}</title>
    <SeoHead title={docTitle} description={description} authors={authors} published={published} tags={tags} image={imageAbs} />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous" />
    <script src="https://cdn.plot.ly/plotly-3.0.0.min.js" charset="utf-8"></script>
  </head>
  <body>
    <ThemeToggle />
    <section class="hero">
      <h1 class="hero-title" set:html={docTitleHtml}></h1>
      <div class="hero-banner">
        <HtmlFragment src="banner.html" />
        <p class="hero-desc">It's nice to have a cute interactive banner!</p>
      </div>
    </section>

    <section class="article-header">
      <Meta title={docTitle} authors={articleFM?.authors} affiliation={articleFM?.affiliation} published={articleFM?.published} />
    </section>

    <section class="content-grid">
      <aside class="toc">
        <div class="title">Table of Contents</div>
        <div id="toc-placeholder"></div>
      </aside>
      <main>
        <Article />
        <style is:inline>
          /* Inline tweak for details blocks used in MDX */
          details { background: var(--code-bg) !important; border: 1px solid var(--border-color) !important; border-radius: 6px; margin: 1em 0; padding: .5em .75em; }
        </style>
      </main>
    </section>

    <Footer citationText='"The Distill Blog Template", 2025.' bibtex={`@misc{distill_blog_template,
  title={The Distill Blog Template},
  author={Some Authors et al},
  year={2025},
}`}
    >
      <div class="references"><h3>References</h3></div>
    </Footer>

    <!-- Medium-like image zoom (lightbox) -->
    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script>
    <script>
      // Init zoom on data-zoomable images, close on scroll/move like Medium
      const initMediumZoom = () => {
        if (!window.mediumZoom) return;
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const background = isDark ? 'rgba(0,0,0,.9)' : 'rgba(0,0,0,.85)';
        const zoom = window.mediumZoom('section.content-grid main img[data-zoomable]', {
          background,
          margin: 24,
          scrollOffset: 0
        });

        let onMove;
        const attachCloseOnMove = () => {
          if (onMove) return;
          onMove = () => { zoom.close(); };
          window.addEventListener('mousemove', onMove, { passive: true });
          window.addEventListener('wheel', onMove, { passive: true });
          window.addEventListener('touchmove', onMove, { passive: true });
        };
        const detachCloseOnMove = () => {
          if (!onMove) return;
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('wheel', onMove);
          window.removeEventListener('touchmove', onMove);
          onMove = null;
        };

        zoom.on('open', attachCloseOnMove);
        zoom.on('close', detachCloseOnMove);

        // React to theme toggle
        const observer = new MutationObserver(() => {
          const dark = document.documentElement.getAttribute('data-theme') === 'dark';
          zoom.update({ background: dark ? 'rgba(0,0,0,.9)' : 'rgba(0,0,0,.85)' });
        });
        observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initMediumZoom, { once: true });
      } else { initMediumZoom(); }
    </script>
    <script>
      // Open external links in a new tab; keep internal anchors in-page
      const setExternalTargets = () => {
        const isExternal = (href) => {
          try { const u = new URL(href, location.href); return u.origin !== location.origin; } catch { return false; }
        };
        document.querySelectorAll('a[href]').forEach(a => {
          const href = a.getAttribute('href');
          if (!href) return;
          if (isExternal(href)) {
            a.setAttribute('target', '_blank');
            a.setAttribute('rel', 'noopener noreferrer');
          } else {
            a.removeAttribute('target');
          }
        });
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setExternalTargets, { once: true });
      } else { setExternalTargets(); }
    </script>

    <script>
      // Build TOC from article headings (h2/h3/h4) and render into the sticky aside
      const buildTOC = () => {
        const holder = document.getElementById('toc-placeholder');
        if (!holder || holder.children.length) return;
        const articleRoot = document.querySelector('section.content-grid main');
        if (!articleRoot) return;
        const headings = articleRoot.querySelectorAll('h2, h3, h4');
        if (!headings.length) return;

        const nav = document.createElement('nav');
        let ulStack = [document.createElement('ul')];
        nav.appendChild(ulStack[0]);

        const levelOf = (tag) => tag === 'H2' ? 2 : tag === 'H3' ? 3 : 4;
        let prev = 2;
        headings.forEach((h) => {
          const lvl = levelOf(h.tagName);
          // ensure id exists
          if (!h.id) h.id = h.textContent.toLowerCase().replace(/\s+/g, '_');
          // adjust depth
          while (lvl > prev) { const ul = document.createElement('ul'); ulStack[ulStack.length-1].lastElementChild?.appendChild(ul); ulStack.push(ul); prev++; }
          while (lvl < prev) { ulStack.pop(); prev--; }
          const li = document.createElement('li');
          const a = document.createElement('a');
          a.href = '#' + h.id; a.textContent = h.textContent; a.target = '_self';
          li.appendChild(a);
          ulStack[ulStack.length-1].appendChild(li);
        });

        holder.appendChild(nav);

        // active link on scroll
        const links = holder.querySelectorAll('a');
        const onScroll = () => {
          for (let i = headings.length - 1; i >= 0; i--) {
            const top = headings[i].getBoundingClientRect().top;
            if (top - 60 <= 0) {
              links.forEach(l => l.classList.remove('active'));
              const id = '#' + headings[i].id;
              const active = Array.from(links).find(l => l.getAttribute('href') === id);
              active && active.classList.add('active');
              break;
            }
          }
        };
        window.addEventListener('scroll', onScroll);
        onScroll();
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', buildTOC, { once: true });
      } else { buildTOC(); }
    </script>
  </body>
</html>


